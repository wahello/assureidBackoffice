[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\n/* Package-scope variables */\nvar Papa;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/harrison_papa-parse/baby-parse.js                                                          //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n/*\n    Baby Parse\n    v0.4.1\n    https://github.com/Rich-Harris/BabyParse\n\n    Created by Rich Harris\n    Maintained by Matt Holt\n\n    Based on Papa Parse v4.0.7 by Matt Holt\n    https://github.com/mholt/PapaParse\n*/\n\n// A configuration object from which to draw default settings\nvar DEFAULTS = {\n    delimiter: \"\",  // empty: auto-detect\n    newline: \"\",    // empty: auto-detect\n    header: false,\n    dynamicTyping: false,\n    preview: 0,\n    step: undefined,\n    comments: false,\n    complete: undefined,\n    skipEmptyLines: false,\n    fastMode: false\n};\n\nPapa = {};\nPapa.parse = CsvToJson;\nPapa.parseFiles = ParseFiles;\nPapa.unparse = JsonToCsv;\nPapa.RECORD_SEP = String.fromCharCode(30);\nPapa.UNIT_SEP = String.fromCharCode(31);\nPapa.BYTE_ORDER_MARK = \"\\ufeff\";\nPapa.BAD_DELIMITERS = [\"\\r\", \"\\n\", \"\\\"\", Papa.BYTE_ORDER_MARK];\nPapa.DefaultDelimiter = \",\";        // Used if not specified and detection fails\nPapa.Parser = Parser;               // For testing/dev only\nPapa.ParserHandle = ParserHandle;   // For testing/dev only\n\nfunction ParseFiles(_input, _config)\n{\n    if (Array.isArray(_input)) {\n        var results = [];\n        _input.forEach(function(input) {\n            if(typeof input === 'object')\n                results.push(ParseFiles(input.file, input.config));\n            else\n                results.push(ParseFiles(input, _config));\n        });\n        return results;\n    } else {\n        var results = {\n            data: [],\n            errors: []\n        };\n        if ((/(\\.csv|\\.txt)$/).test(_input)) {\n            try {\n                var contents = fs.readFileSync(_input).toString();\n                return CsvToJson(contents, _config);\n            } catch (err) {\n                results.errors.push(err);\n                return results;\n            }\n        } else {\n            results.errors.push({\n                type: '',\n                code: '',\n                message: 'Unsupported file type.',\n                row: ''\n            });\n            return results;\n        }\n    }\n}\n\nfunction CsvToJson(_input, _config)\n{\n    var config = copyAndValidateConfig(_config);\n    var ph = new ParserHandle(config);\n    var results = ph.parse(_input);\n    if (isFunction(config.complete))\n        config.complete(results);\n    return results;\n}\n\n\n\n\nfunction JsonToCsv(_input, _config)\n{\n    var _output = \"\";\n    var _fields = [];\n\n    // Default configuration\n    var _quotes = false;    // whether to surround every datum with quotes\n    var _delimiter = \",\";   // delimiting character\n    var _newline = \"\\r\\n\";  // newline character(s)\n\n    unpackConfig();\n\n    if (typeof _input === 'string')\n        _input = JSON.parse(_input);\n\n    if (_input instanceof Array)\n    {\n        if (!_input.length || _input[0] instanceof Array)\n            return serialize(null, _input);\n        else if (typeof _input[0] === 'object')\n            return serialize(objectKeys(_input[0]), _input);\n    }\n    else if (typeof _input === 'object')\n    {\n        if (typeof _input.data === 'string')\n            _input.data = JSON.parse(_input.data);\n\n        if (_input.data instanceof Array)\n        {\n            if (!_input.fields)\n                _input.fields = _input.data[0] instanceof Array\n                                ? _input.fields\n                                : objectKeys(_input.data[0]);\n\n            if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')\n                _input.data = [_input.data];    // handles input like [1,2,3] or [\"asdf\"]\n        }\n\n        return serialize(_input.fields || [], _input.data || []);\n    }\n\n    // Default (any valid paths should return before this)\n    throw \"exception: Unable to serialize unrecognized input\";\n\n\n    function unpackConfig()\n    {\n        if (typeof _config !== 'object')\n            return;\n\n        if (typeof _config.delimiter === 'string'\n            && _config.delimiter.length == 1\n            && Papa.BAD_DELIMITERS.indexOf(_config.delimiter) == -1)\n        {\n            _delimiter = _config.delimiter;\n        }\n\n        if (typeof _config.quotes === 'boolean'\n            || _config.quotes instanceof Array)\n            _quotes = _config.quotes;\n\n        if (typeof _config.newline === 'string')\n            _newline = _config.newline;\n    }\n\n\n    // Turns an object's keys into an array\n    function objectKeys(obj)\n    {\n        if (typeof obj !== 'object')\n            return [];\n        var keys = [];\n        for (var key in obj)\n            keys.push(key);\n        return keys;\n    }\n\n    // The double for loop that iterates the data and writes out a CSV string including header row\n    function serialize(fields, data)\n    {\n        var csv = \"\";\n\n        if (typeof fields === 'string')\n            fields = JSON.parse(fields);\n        if (typeof data === 'string')\n            data = JSON.parse(data);\n\n        var hasHeader = fields instanceof Array && fields.length > 0;\n        var dataKeyedByField = !(data[0] instanceof Array);\n\n        // If there a header row, write it first\n        if (hasHeader)\n        {\n            for (var i = 0; i < fields.length; i++)\n            {\n                if (i > 0)\n                    csv += _delimiter;\n                csv += safe(fields[i], i);\n            }\n            if (data.length > 0)\n                csv += _newline;\n        }\n\n        // Then write out the data\n        for (var row = 0; row < data.length; row++)\n        {\n            var maxCol = hasHeader ? fields.length : data[row].length;\n\n            for (var col = 0; col < maxCol; col++)\n            {\n                if (col > 0)\n                    csv += _delimiter;\n                var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n                csv += safe(data[row][colIdx], col);\n            }\n\n            if (row < data.length - 1)\n                csv += _newline;\n        }\n\n        return csv;\n    }\n\n    // Encloses a value around quotes if needed (makes a value safe for CSV insertion)\n    function safe(str, col)\n    {\n        if (typeof str === \"undefined\" || str === null)\n            return \"\";\n\n        str = str.toString().replace(/\"/g, '\"\"');\n\n        var needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n                        || (_quotes instanceof Array && _quotes[col])\n                        || hasAny(str, Papa.BAD_DELIMITERS)\n                        || str.indexOf(_delimiter) > -1\n                        || str.charAt(0) == ' '\n                        || str.charAt(str.length - 1) == ' ';\n\n        return needsQuotes ? '\"' + str + '\"' : str;\n    }\n\n    function hasAny(str, substrings)\n    {\n        for (var i = 0; i < substrings.length; i++)\n            if (str.indexOf(substrings[i]) > -1)\n                return true;\n        return false;\n    }\n}\n\n\n\n\n\n\n// Use one ParserHandle per entire CSV file or string\nfunction ParserHandle(_config)\n{\n    // One goal is to minimize the use of regular expressions...\n    var FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\n    var self = this;\n    var _stepCounter = 0;   // Number of times step was called (number of rows parsed)\n    var _input;             // The input being parsed\n    var _parser;            // The core parser being used\n    var _paused = false;    // Whether we are paused or not\n    var _delimiterError;    // Temporary state between delimiter detection and processing results\n    var _fields = [];       // Fields are from the header row of the input, if there is one\n    var _results = {        // The last results returned from the parser\n        data: [],\n        errors: [],\n        meta: {}\n    };\n\n    if (isFunction(_config.step))\n    {\n        var userStep = _config.step;\n        _config.step = function(results)\n        {\n            _results = results;\n\n            if (needsHeaderRow())\n                processResults();\n            else    // only call user's step function after header row\n            {\n                processResults();\n\n                // It's possbile that this line was empty and there's no row here after all\n                if (_results.data.length == 0)\n                    return;\n\n                _stepCounter += results.data.length;\n                if (_config.preview && _stepCounter > _config.preview)\n                    _parser.abort();\n                else\n                    userStep(_results, self);\n            }\n        };\n    }\n\n    this.parse = function(input)\n    {\n        if (!_config.newline)\n            _config.newline = guessLineEndings(input);\n\n        _delimiterError = false;\n        if (!_config.delimiter)\n        {\n            var delimGuess = guessDelimiter(input);\n            if (delimGuess.successful)\n                _config.delimiter = delimGuess.bestDelimiter;\n            else\n            {\n                _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n                _config.delimiter = Papa.DefaultDelimiter;\n            }\n            _results.meta.delimiter = _config.delimiter;\n        }\n\n        var parserConfig = copy(_config);\n        if (_config.preview && _config.header)\n            parserConfig.preview++; // to compensate for header row\n\n        _input = input;\n        _parser = new Parser(parserConfig);\n        _results = _parser.parse(_input);\n        processResults();\n        if (isFunction(_config.complete) && !_paused && (!self.streamer || self.streamer.finished()))\n            _config.complete(_results);\n        return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n    };\n\n    this.pause = function()\n    {\n        _paused = true;\n        _parser.abort();\n        _input = _input.substr(_parser.getCharIndex());\n    };\n\n    this.resume = function()\n    {\n        _paused = false;\n        _parser = new Parser(_config);\n        _parser.parse(_input);\n        if (!_paused)\n        {\n            if (self.streamer && !self.streamer.finished())\n                self.streamer.resume();     // more of the file yet to come\n            else if (isFunction(_config.complete))\n                _config.complete(_results);\n        }\n    };\n\n    this.abort = function()\n    {\n        _parser.abort();\n        if (isFunction(_config.complete))\n            _config.complete(_results);\n        _input = \"\";\n    };\n\n    function processResults()\n    {\n        if (_results && _delimiterError)\n        {\n            addError(\"Delimiter\", \"UndetectableDelimiter\", \"Unable to auto-detect delimiting character; defaulted to '\"+Papa.DefaultDelimiter+\"'\");\n            _delimiterError = false;\n        }\n\n        if (_config.skipEmptyLines)\n        {\n            for (var i = 0; i < _results.data.length; i++)\n                if (_results.data[i].length == 1 && _results.data[i][0] == \"\")\n                    _results.data.splice(i--, 1);\n        }\n\n        if (needsHeaderRow())\n            fillHeaderFields();\n\n        return applyHeaderAndDynamicTyping();\n    }\n\n    function needsHeaderRow()\n    {\n        return _config.header && _fields.length == 0;\n    }\n\n    function fillHeaderFields()\n    {\n        if (!_results)\n            return;\n        for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n            for (var j = 0; j < _results.data[i].length; j++)\n                _fields.push(_results.data[i][j]);\n        _results.data.splice(0, 1);\n    }\n\n    function applyHeaderAndDynamicTyping()\n    {\n        if (!_results || (!_config.header && !_config.dynamicTyping))\n            return _results;\n\n        for (var i = 0; i < _results.data.length; i++)\n        {\n            var row = {};\n\n            for (var j = 0; j < _results.data[i].length; j++)\n            {\n                if (_config.dynamicTyping)\n                {\n                    var value = _results.data[i][j];\n                    if (value == \"true\" || value === \"TRUE\")\n                        _results.data[i][j] = true;\n                    else if (value == \"false\" || value === \"FALSE\")\n                        _results.data[i][j] = false;\n                    else\n                        _results.data[i][j] = tryParseFloat(value);\n                }\n\n                if (_config.header)\n                {\n                    if (j >= _fields.length)\n                    {\n                        if (!row[\"__parsed_extra\"])\n                            row[\"__parsed_extra\"] = [];\n                        row[\"__parsed_extra\"].push(_results.data[i][j]);\n                    }\n                    else\n                        row[_fields[j]] = _results.data[i][j];\n                }\n            }\n\n            if (_config.header)\n            {\n                _results.data[i] = row;\n                if (j > _fields.length)\n                    addError(\"FieldMismatch\", \"TooManyFields\", \"Too many fields: expected \" + _fields.length + \" fields but parsed \" + j, i);\n                else if (j < _fields.length)\n                    addError(\"FieldMismatch\", \"TooFewFields\", \"Too few fields: expected \" + _fields.length + \" fields but parsed \" + j, i);\n            }\n        }\n\n        if (_config.header && _results.meta)\n            _results.meta.fields = _fields;\n        return _results;\n    }\n\n    function guessDelimiter(input)\n    {\n        var delimChoices = [\",\", \"\\t\", \"|\", \";\", Papa.RECORD_SEP, Papa.UNIT_SEP];\n        var bestDelim, bestDelta, fieldCountPrevRow;\n\n        for (var i = 0; i < delimChoices.length; i++)\n        {\n            var delim = delimChoices[i];\n            var delta = 0, avgFieldCount = 0;\n            fieldCountPrevRow = undefined;\n\n            var preview = new Parser({\n                delimiter: delim,\n                preview: 10\n            }).parse(input);\n\n            for (var j = 0; j < preview.data.length; j++)\n            {\n                var fieldCount = preview.data[j].length;\n                avgFieldCount += fieldCount;\n\n                if (typeof fieldCountPrevRow === 'undefined')\n                {\n                    fieldCountPrevRow = fieldCount;\n                    continue;\n                }\n                else if (fieldCount > 1)\n                {\n                    delta += Math.abs(fieldCount - fieldCountPrevRow);\n                    fieldCountPrevRow = fieldCount;\n                }\n            }\n\n            avgFieldCount /= preview.data.length;\n\n            if ((typeof bestDelta === 'undefined' || delta < bestDelta)\n                && avgFieldCount > 1.99)\n            {\n                bestDelta = delta;\n                bestDelim = delim;\n            }\n        }\n\n        _config.delimiter = bestDelim;\n\n        return {\n            successful: !!bestDelim,\n            bestDelimiter: bestDelim\n        }\n    }\n\n    function guessLineEndings(input)\n    {\n        input = input.substr(0, 1024*1024); // max length 1 MB\n\n        var r = input.split('\\r');\n\n        if (r.length == 1)\n            return '\\n';\n\n        var numWithN = 0;\n        for (var i = 0; i < r.length; i++)\n        {\n            if (r[i][0] == '\\n')\n                numWithN++;\n        }\n\n        return numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n    }\n\n    function tryParseFloat(val)\n    {\n        var isNumber = FLOAT.test(val);\n        return isNumber ? parseFloat(val) : val;\n    }\n\n    function addError(type, code, msg, row)\n    {\n        _results.errors.push({\n            type: type,\n            code: code,\n            message: msg,\n            row: row\n        });\n    }\n}\n\n\n\n\n\n\n// The core parser implements speedy and correct CSV parsing\nfunction Parser(config)\n{\n    // Unpack the config object\n    config = config || {};\n    var delim = config.delimiter;\n    var newline = config.newline;\n    var comments = config.comments;\n    var step = config.step;\n    var preview = config.preview;\n    var fastMode = config.fastMode;\n\n    // Delimiter must be valid\n    if (typeof delim !== 'string'\n        || delim.length != 1\n        || Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n        delim = \",\";\n\n    // Comment character must be valid\n    if (comments === delim)\n        throw \"Comment character same as delimiter\";\n    else if (comments === true)\n        comments = \"#\";\n    else if (typeof comments !== 'string'\n        || Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n        comments = false;\n\n    // Newline must be valid: \\r, \\n, or \\r\\n\n    if (newline != '\\n' && newline != '\\r' && newline != '\\r\\n')\n        newline = '\\n';\n\n    // We're gonna need these at the Parser scope\n    var cursor = 0;\n    var aborted = false;\n\n    this.parse = function(input)\n    {\n        // For some reason, in Chrome, this speeds things up (!?)\n        if (typeof input !== 'string')\n            throw \"Input must be a string\";\n\n        // We don't need to compute some of these every time parse() is called,\n        // but having them in a more local scope seems to perform better\n        var inputLen = input.length,\n            delimLen = delim.length,\n            newlineLen = newline.length,\n            commentsLen = comments.length;\n        var stepIsFunction = typeof step === 'function';\n\n        // Establish starting state\n        cursor = 0;\n        var data = [], errors = [], row = [];\n\n        if (!input)\n            return returnable();\n\n        if (fastMode)\n        {\n            // Fast mode assumes there are no quoted fields in the input\n            var rows = input.split(newline);\n            for (var i = 0; i < rows.length; i++)\n            {\n                if (comments && rows[i].substr(0, commentsLen) == comments)\n                    continue;\n                if (stepIsFunction)\n                {\n                    data = [ rows[i].split(delim) ];\n                    doStep();\n                    if (aborted)\n                        return returnable();\n                }\n                else\n                    data.push(rows[i].split(delim));\n                if (preview && i >= preview)\n                {\n                    data = data.slice(0, preview);\n                    return returnable(true);\n                }\n            }\n            return returnable();\n        }\n\n        var nextDelim = input.indexOf(delim, cursor);\n        var nextNewline = input.indexOf(newline, cursor);\n\n        // Parser loop\n        for (;;)\n        {\n            // Field has opening quote\n            if (input[cursor] == '\"')\n            {\n                // Start our search for the closing quote where the cursor is\n                var quoteSearch = cursor;\n\n                // Skip the opening quote\n                cursor++;\n\n                for (;;)\n                {\n                    // Find closing quote\n                    var quoteSearch = input.indexOf('\"', quoteSearch+1);\n\n                    if (quoteSearch === -1)\n                    {\n                        // No closing quote... what a pity\n                        errors.push({\n                            type: \"Quotes\",\n                            code: \"MissingQuotes\",\n                            message: \"Quoted field unterminated\",\n                            row: data.length,   // row has yet to be inserted\n                            index: cursor\n                        });\n                        return finish();\n                    }\n\n                    if (quoteSearch === inputLen-1)\n                    {\n                        // Closing quote at EOF\n                        row.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n                        data.push(row);\n                        if (stepIsFunction)\n                            doStep();\n                        return returnable();\n                    }\n\n                    // If this quote is escaped, it's part of the data; skip it\n                    if (input[quoteSearch+1] == '\"')\n                    {\n                        quoteSearch++;\n                        continue;\n                    }\n\n                    if (input[quoteSearch+1] == delim)\n                    {\n                        // Closing quote followed by delimiter\n                        row.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n                        cursor = quoteSearch + 1 + delimLen;\n                        nextDelim = input.indexOf(delim, cursor);\n                        nextNewline = input.indexOf(newline, cursor);\n                        break;\n                    }\n\n                    if (input.substr(quoteSearch+1, newlineLen) === newline)\n                    {\n                        // Closing quote followed by newline\n                        row.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n                        saveRow(quoteSearch + 1 + newlineLen);\n                        nextDelim = input.indexOf(delim, cursor);   // because we may have skipped the nextDelim in the quoted field\n\n                        if (stepIsFunction)\n                        {\n                            doStep();\n                            if (aborted)\n                                return returnable();\n                        }\n\n                        if (preview && data.length >= preview)\n                            return returnable(true);\n\n                        break;\n                    }\n                }\n\n                continue;\n            }\n\n            // Comment found at start of new line\n            if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)\n            {\n                if (nextNewline == -1)  // Comment ends at EOF\n                    return returnable();\n                cursor = nextNewline + newlineLen;\n                nextNewline = input.indexOf(newline, cursor);\n                nextDelim = input.indexOf(delim, cursor);\n                continue;\n            }\n\n            // Next delimiter comes before next newline, so we've reached end of field\n            if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n            {\n                row.push(input.substring(cursor, nextDelim));\n                cursor = nextDelim + delimLen;\n                nextDelim = input.indexOf(delim, cursor);\n                continue;\n            }\n\n            // End of row\n            if (nextNewline !== -1)\n            {\n                row.push(input.substring(cursor, nextNewline));\n                saveRow(nextNewline + newlineLen);\n\n                if (stepIsFunction)\n                {\n                    doStep();\n                    if (aborted)\n                        return returnable();\n                }\n\n                if (preview && data.length >= preview)\n                    return returnable(true);\n\n                continue;\n            }\n\n            break;\n        }\n\n\n        return finish();\n\n\n        // Appends the remaining input from cursor to the end into\n        // row, saves the row, calls step, and returns the results.\n        function finish()\n        {\n            row.push(input.substr(cursor));\n            data.push(row);\n            cursor = inputLen;  // important in case parsing is paused\n            if (stepIsFunction)\n                doStep();\n            return returnable();\n        }\n\n        // Appends the current row to the results. It sets the cursor\n        // to newCursor and finds the nextNewline. The caller should\n        // take care to execute user's step function and check for\n        // preview and end parsing if necessary.\n        function saveRow(newCursor)\n        {\n            data.push(row);\n            row = [];\n            cursor = newCursor;\n            nextNewline = input.indexOf(newline, cursor);\n        }\n\n        // Returns an object with the results, errors, and meta.\n        function returnable(stopped)\n        {\n            return {\n                data: data,\n                errors: errors,\n                meta: {\n                    delimiter: delim,\n                    linebreak: newline,\n                    aborted: aborted,\n                    truncated: !!stopped\n                }\n            };\n        }\n\n        // Executes the user's step function and resets data & errors.\n        function doStep()\n        {\n            step(returnable());\n            data = [], errors = [];\n        }\n    };\n\n    // Sets the abort flag\n    this.abort = function()\n    {\n        aborted = true;\n    };\n\n    // Gets the cursor position\n    this.getCharIndex = function()\n    {\n        return cursor;\n    };\n}\n\n\n\n\n// Replaces bad config values with good, default ones\nfunction copyAndValidateConfig(origConfig)\n{\n    if (typeof origConfig !== 'object')\n        origConfig = {};\n\n    var config = copy(origConfig);\n\n    if (typeof config.delimiter !== 'string'\n        || config.delimiter.length != 1\n        || Papa.BAD_DELIMITERS.indexOf(config.delimiter) > -1)\n        config.delimiter = DEFAULTS.delimiter;\n\n    if (config.newline != '\\n'\n        && config.newline != '\\r'\n        && config.newline != '\\r\\n')\n        config.newline = DEFAULTS.newline;\n\n    if (typeof config.header !== 'boolean')\n        config.header = DEFAULTS.header;\n\n    if (typeof config.dynamicTyping !== 'boolean')\n        config.dynamicTyping = DEFAULTS.dynamicTyping;\n\n    if (typeof config.preview !== 'number')\n        config.preview = DEFAULTS.preview;\n\n    if (typeof config.step !== 'function')\n        config.step = DEFAULTS.step;\n\n    if (typeof config.complete !== 'function')\n        config.complete = DEFAULTS.complete;\n\n    if (typeof config.skipEmptyLines !== 'boolean')\n        config.skipEmptyLines = DEFAULTS.skipEmptyLines;\n\n    if (typeof config.fastMode !== 'boolean')\n        config.fastMode = DEFAULTS.fastMode;\n\n    return config;\n}\n\nfunction copy(obj)\n{\n    if (typeof obj !== 'object')\n        return obj;\n    var cpy = obj instanceof Array ? [] : {};\n    for (var key in obj)\n        cpy[key] = copy(obj[key]);\n    return cpy;\n}\n\nfunction isFunction(func)\n{\n    return typeof func === 'function';\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['harrison:papa-parse'] = {}, {\n  Papa: Papa\n});\n\n})();\n","servePath":"/packages/harrison_papa-parse.js"}]