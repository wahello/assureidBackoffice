{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"fs-extra","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"fs"}]},{"source":"meteor/underscore","imported":["_"],"specifiers":[{"kind":"named","imported":"_","local":"_"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]}],"exports":{"exported":["WriteStream"],"specifiers":[{"kind":"local","local":"WriteStream","exported":"default"}]}}},"options":{"filename":"packages/ostrio:files/write-stream.js","filenameRelative":"packages/ostrio:files/write-stream.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/ostrio:files/write-stream.js.map","sourceFileName":"packages/ostrio:files/write-stream.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"write-stream"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n  \"default\": function () {\n    return WriteStream;\n  }\n});\nvar fs = void 0;\nmodule.watch(require(\"fs-extra\"), {\n  \"default\": function (v) {\n    fs = v;\n  }\n}, 0);\n\nvar _ = void 0;\n\nmodule.watch(require(\"meteor/underscore\"), {\n  _: function (v) {\n    _ = v;\n  }\n}, 1);\nvar Meteor = void 0;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 2);\n\nvar NOOP = function () {}; /*\n                            * @const {Object} bound   - Meteor.bindEnvironment (Fiber wrapper)\n                            * @const {Object} fdCache - File Descriptors Cache\n                            */\n\nvar bound = Meteor.bindEnvironment(function (callback) {\n  return callback();\n});\nvar fdCache = {}; /*\n                   * @private\n                   * @locus Server\n                   * @class WriteStream\n                   * @param path      {String} - Path to file on FS\n                   * @param maxLength {Number} - Max amount of chunks in stream\n                   * @param file      {Object} - fileRef Object\n                   * @summary writableStream wrapper class, makes sure chunks is written in given order. Implementation of queue stream.\n                   */\n\nvar WriteStream = function () {\n  function WriteStream(path, maxLength, file, permissions) {\n    var _this = this;\n\n    (0, _classCallCheck3.default)(this, WriteStream);\n    this.path = path;\n    this.maxLength = maxLength;\n    this.file = file;\n    this.permissions = permissions;\n\n    if (!this.path || !_.isString(this.path)) {\n      return;\n    }\n\n    this.fd = null;\n    this.writtenChunks = 0;\n    this.ended = false;\n    this.aborted = false;\n\n    if (fdCache[this.path] && !fdCache[this.path].ended && !fdCache[this.path].aborted) {\n      this.fd = fdCache[this.path].fd;\n      this.writtenChunks = fdCache[this.path].writtenChunks;\n    } else {\n      fs.ensureFile(this.path, function (efError) {\n        bound(function () {\n          if (efError) {\n            throw new Meteor.Error(500, '[FilesCollection] [writeStream] [ensureFile] [Error:]', efError);\n          } else {\n            fs.open(_this.path, 'r+', _this.permissions, function (oError, fd) {\n              bound(function () {\n                if (oError) {\n                  throw new Meteor.Error(500, '[FilesCollection] [writeStream] [ensureFile] [open] [Error:]', oError);\n                } else {\n                  _this.fd = fd;\n                  fdCache[_this.path] = _this;\n                }\n              });\n            });\n          }\n        });\n      });\n    }\n  } /*\n     * @memberOf writeStream\n     * @name write\n     * @param {Number} num - Chunk position in a stream\n     * @param {Buffer} chunk - Buffer (chunk binary data)\n     * @param {Function} callback - Callback\n     * @summary Write chunk in given order\n     * @returns {Boolean} - True if chunk is sent to stream, false if chunk is set into queue\n     */\n\n  WriteStream.prototype.write = function () {\n    function write(num, chunk, callback) {\n      var _this2 = this;\n\n      if (!this.aborted && !this.ended) {\n        if (this.fd) {\n          fs.write(this.fd, chunk, 0, chunk.length, (num - 1) * this.file.chunkSize, function (error, written, buffer) {\n            bound(function () {\n              callback && callback(error, written, buffer);\n\n              if (error) {\n                console.warn('[FilesCollection] [writeStream] [write] [Error:]', error);\n\n                _this2.abort();\n              } else {\n                ++_this2.writtenChunks;\n              }\n            });\n          });\n        } else {\n          Meteor.setTimeout(function () {\n            _this2.write(num, chunk, callback);\n          }, 25);\n        }\n      }\n\n      return false;\n    }\n\n    return write;\n  }(); /*\n        * @memberOf writeStream\n        * @name end\n        * @param {Function} callback - Callback\n        * @summary Finishes writing to writableStream, only after all chunks in queue is written\n        * @returns {Boolean} - True if stream is fulfilled, false if queue is in progress\n        */\n\n  WriteStream.prototype.end = function () {\n    function end(callback) {\n      var _this3 = this;\n\n      if (!this.aborted && !this.ended) {\n        if (this.writtenChunks === this.maxLength) {\n          fs.close(this.fd, function () {\n            bound(function () {\n              delete fdCache[_this3.path];\n              _this3.ended = true;\n              callback && callback(void 0, true);\n            });\n          });\n          return true;\n        }\n\n        fs.stat(this.path, function (error, stat) {\n          bound(function () {\n            if (!error && stat) {\n              _this3.writtenChunks = Math.ceil(stat.size / _this3.file.chunkSize);\n            }\n\n            return Meteor.setTimeout(function () {\n              _this3.end(callback);\n            }, 25);\n          });\n        });\n      } else {\n        callback && callback(void 0, this.ended);\n      }\n\n      return false;\n    }\n\n    return end;\n  }(); /*\n        * @memberOf writeStream\n        * @name abort\n        * @param {Function} callback - Callback\n        * @summary Aborts writing to writableStream, removes created file\n        * @returns {Boolean} - True\n        */\n\n  WriteStream.prototype.abort = function () {\n    function abort(callback) {\n      this.aborted = true;\n      delete fdCache[this.path];\n      fs.unlink(this.path, callback || NOOP);\n      return true;\n    }\n\n    return abort;\n  }(); /*\n        * @memberOf writeStream\n        * @name stop\n        * @summary Stop writing to writableStream\n        * @returns {Boolean} - True\n        */\n\n  WriteStream.prototype.stop = function () {\n    function stop() {\n      this.aborted = true;\n      delete fdCache[this.path];\n      return true;\n    }\n\n    return stop;\n  }();\n\n  return WriteStream;\n}();","map":{"version":3,"sources":["packages/ostrio:files/write-stream.js"],"names":["module","export","WriteStream","fs","watch","require","v","_","Meteor","NOOP","bound","bindEnvironment","callback","fdCache","path","maxLength","file","permissions","isString","fd","writtenChunks","ended","aborted","ensureFile","efError","Error","open","oError","write","num","chunk","length","chunkSize","error","written","buffer","console","warn","abort","setTimeout","end","close","stat","Math","ceil","size","unlink","stop"],"mappings":"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","file":"packages/ostrio:files/write-stream.js.map","sourcesContent":["import fs         from 'fs-extra';\nimport { _ }      from 'meteor/underscore';\nimport { Meteor } from 'meteor/meteor';\nconst NOOP = () => {};\n\n/*\n * @const {Object} bound   - Meteor.bindEnvironment (Fiber wrapper)\n * @const {Object} fdCache - File Descriptors Cache\n */\nconst bound   = Meteor.bindEnvironment(callback => callback());\nconst fdCache = {};\n\n/*\n * @private\n * @locus Server\n * @class WriteStream\n * @param path      {String} - Path to file on FS\n * @param maxLength {Number} - Max amount of chunks in stream\n * @param file      {Object} - fileRef Object\n * @summary writableStream wrapper class, makes sure chunks is written in given order. Implementation of queue stream.\n */\nexport default class WriteStream {\n  constructor(path, maxLength, file, permissions) {\n    this.path = path;\n    this.maxLength = maxLength;\n    this.file = file;\n    this.permissions = permissions;\n    if (!this.path || !_.isString(this.path)) {\n      return;\n    }\n\n    this.fd            = null;\n    this.writtenChunks = 0;\n    this.ended         = false;\n    this.aborted       = false;\n\n    if (fdCache[this.path] && !fdCache[this.path].ended && !fdCache[this.path].aborted) {\n      this.fd = fdCache[this.path].fd;\n      this.writtenChunks = fdCache[this.path].writtenChunks;\n    } else {\n      fs.ensureFile(this.path, (efError) => {\n        bound(() => {\n          if (efError) {\n            throw new Meteor.Error(500, '[FilesCollection] [writeStream] [ensureFile] [Error:]', efError);\n          } else {\n            fs.open(this.path, 'r+', this.permissions, (oError, fd) => {\n              bound(() => {\n                if (oError) {\n                  throw new Meteor.Error(500, '[FilesCollection] [writeStream] [ensureFile] [open] [Error:]', oError);\n                } else {\n                  this.fd = fd;\n                  fdCache[this.path] = this;\n                }\n              });\n            });\n          }\n        });\n      });\n    }\n  }\n\n  /*\n   * @memberOf writeStream\n   * @name write\n   * @param {Number} num - Chunk position in a stream\n   * @param {Buffer} chunk - Buffer (chunk binary data)\n   * @param {Function} callback - Callback\n   * @summary Write chunk in given order\n   * @returns {Boolean} - True if chunk is sent to stream, false if chunk is set into queue\n   */\n  write(num, chunk, callback) {\n    if (!this.aborted && !this.ended) {\n      if (this.fd) {\n        fs.write(this.fd, chunk, 0, chunk.length, (num - 1) * this.file.chunkSize, (error, written, buffer) => {\n          bound(() => {\n            callback && callback(error, written, buffer);\n            if (error) {\n              console.warn('[FilesCollection] [writeStream] [write] [Error:]', error);\n              this.abort();\n            } else {\n              ++this.writtenChunks;\n            }\n          });\n        });\n      } else {\n        Meteor.setTimeout(() => {\n          this.write(num, chunk, callback);\n        }, 25);\n      }\n    }\n    return false;\n  }\n\n  /*\n   * @memberOf writeStream\n   * @name end\n   * @param {Function} callback - Callback\n   * @summary Finishes writing to writableStream, only after all chunks in queue is written\n   * @returns {Boolean} - True if stream is fulfilled, false if queue is in progress\n   */\n  end(callback) {\n    if (!this.aborted && !this.ended) {\n      if (this.writtenChunks === this.maxLength) {\n        fs.close(this.fd, () => {\n          bound(() => {\n            delete fdCache[this.path];\n            this.ended = true;\n            callback && callback(void 0, true);\n          });\n        });\n        return true;\n      }\n\n      fs.stat(this.path, (error, stat) => {\n        bound(() => {\n          if (!error && stat) {\n            this.writtenChunks = Math.ceil(stat.size / this.file.chunkSize);\n          }\n\n          return Meteor.setTimeout(() => {\n            this.end(callback);\n          }, 25);\n        });\n      });\n    } else {\n      callback && callback(void 0, this.ended);\n    }\n    return false;\n  }\n\n  /*\n   * @memberOf writeStream\n   * @name abort\n   * @param {Function} callback - Callback\n   * @summary Aborts writing to writableStream, removes created file\n   * @returns {Boolean} - True\n   */\n  abort(callback) {\n    this.aborted = true;\n    delete fdCache[this.path];\n    fs.unlink(this.path, (callback || NOOP));\n    return true;\n  }\n\n  /*\n   * @memberOf writeStream\n   * @name stop\n   * @summary Stop writing to writableStream\n   * @returns {Boolean} - True\n   */\n  stop() {\n    this.aborted = true;\n    delete fdCache[this.path];\n    return true;\n  }\n}\n"]},"hash":"4f0174658584a00ef29da6b7569d1182de7c2440"}
