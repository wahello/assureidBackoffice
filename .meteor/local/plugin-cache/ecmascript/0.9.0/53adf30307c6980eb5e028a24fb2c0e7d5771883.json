{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"meteor/underscore","imported":["_"],"specifiers":[{"kind":"named","imported":"_","local":"_"}]},{"source":"meteor/mongo","imported":["Mongo"],"specifiers":[{"kind":"named","imported":"Mongo","local":"Mongo"}]},{"source":"meteor/webapp","imported":["WebApp"],"specifiers":[{"kind":"named","imported":"WebApp","local":"WebApp"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/random","imported":["Random"],"specifiers":[{"kind":"named","imported":"Random","local":"Random"}]},{"source":"meteor/ostrio:cookies","imported":["Cookies"],"specifiers":[{"kind":"named","imported":"Cookies","local":"Cookies"}]},{"source":"./write-stream.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"WriteStream"}]},{"source":"meteor/check","imported":["check","Match"],"specifiers":[{"kind":"named","imported":"check","local":"check"},{"kind":"named","imported":"Match","local":"Match"}]},{"source":"./core.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"FilesCollectionCore"}]},{"source":"./lib.js","imported":["fixJSONParse","fixJSONStringify"],"specifiers":[{"kind":"named","imported":"fixJSONParse","local":"fixJSONParse"},{"kind":"named","imported":"fixJSONStringify","local":"fixJSONStringify"}]},{"source":"fs-extra","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"fs"}]},{"source":"querystring","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"nodeQs"}]},{"source":"request","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"request"}]},{"source":"file-type","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"fileType"}]},{"source":"path","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"nodePath"}]}],"exports":{"exported":["FilesCollection"],"specifiers":[{"kind":"local","local":"FilesCollection","exported":"FilesCollection"}]}}},"options":{"filename":"packages/ostrio:files/server.js","filenameRelative":"packages/ostrio:files/server.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/ostrio:files/server.js.map","sourceFileName":"packages/ostrio:files/server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"server"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n  FilesCollection: function () {\n    return FilesCollection;\n  }\n});\n\nvar _ = void 0;\n\nmodule.watch(require(\"meteor/underscore\"), {\n  _: function (v) {\n    _ = v;\n  }\n}, 0);\nvar Mongo = void 0;\nmodule.watch(require(\"meteor/mongo\"), {\n  Mongo: function (v) {\n    Mongo = v;\n  }\n}, 1);\nvar WebApp = void 0;\nmodule.watch(require(\"meteor/webapp\"), {\n  WebApp: function (v) {\n    WebApp = v;\n  }\n}, 2);\nvar Meteor = void 0;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 3);\nvar Random = void 0;\nmodule.watch(require(\"meteor/random\"), {\n  Random: function (v) {\n    Random = v;\n  }\n}, 4);\nvar Cookies = void 0;\nmodule.watch(require(\"meteor/ostrio:cookies\"), {\n  Cookies: function (v) {\n    Cookies = v;\n  }\n}, 5);\nvar WriteStream = void 0;\nmodule.watch(require(\"./write-stream.js\"), {\n  \"default\": function (v) {\n    WriteStream = v;\n  }\n}, 6);\nvar check = void 0,\n    Match = void 0;\nmodule.watch(require(\"meteor/check\"), {\n  check: function (v) {\n    check = v;\n  },\n  Match: function (v) {\n    Match = v;\n  }\n}, 7);\nvar FilesCollectionCore = void 0;\nmodule.watch(require(\"./core.js\"), {\n  \"default\": function (v) {\n    FilesCollectionCore = v;\n  }\n}, 8);\nvar fixJSONParse = void 0,\n    fixJSONStringify = void 0;\nmodule.watch(require(\"./lib.js\"), {\n  fixJSONParse: function (v) {\n    fixJSONParse = v;\n  },\n  fixJSONStringify: function (v) {\n    fixJSONStringify = v;\n  }\n}, 9);\nvar fs = void 0;\nmodule.watch(require(\"fs-extra\"), {\n  \"default\": function (v) {\n    fs = v;\n  }\n}, 10);\nvar nodeQs = void 0;\nmodule.watch(require(\"querystring\"), {\n  \"default\": function (v) {\n    nodeQs = v;\n  }\n}, 11);\nvar request = void 0;\nmodule.watch(require(\"request\"), {\n  \"default\": function (v) {\n    request = v;\n  }\n}, 12);\nvar fileType = void 0;\nmodule.watch(require(\"file-type\"), {\n  \"default\": function (v) {\n    fileType = v;\n  }\n}, 13);\nvar nodePath = void 0;\nmodule.watch(require(\"path\"), {\n  \"default\": function (v) {\n    nodePath = v;\n  }\n}, 14);\n/*\n * @const {Object} bound  - Meteor.bindEnvironment (Fiber wrapper)\n * @const {Function} NOOP - No Operation function, placeholder for required callbacks\n */var bound = Meteor.bindEnvironment(function (callback) {\n  return callback();\n});\n\nvar NOOP = function () {}; /*\n                            * @locus Anywhere\n                            * @class FilesCollection\n                            * @param config           {Object}   - [Both]   Configuration object with next properties:\n                            * @param config.debug     {Boolean}  - [Both]   Turn on/of debugging and extra logging\n                            * @param config.schema    {Object}   - [Both]   Collection Schema\n                            * @param config.public    {Boolean}  - [Both]   Store files in folder accessible for proxy servers, for limits, and more - read docs\n                            * @param config.strict    {Boolean}  - [Server] Strict mode for partial content, if is `true` server will return `416` response code, when `range` is not specified, otherwise server return `206`\n                            * @param config.protected {Function} - [Server] If `true` - files will be served only to authorized users, if `function()` - you're able to check visitor's permissions in your own way function's context has:\n                            *  - `request`\n                            *  - `response`\n                            *  - `user()`\n                            *  - `userId`\n                            * @param config.chunkSize      {Number}  - [Both] Upload chunk size, default: 524288 bytes (0,5 Mb)\n                            * @param config.permissions    {Number}  - [Server] Permissions which will be set to uploaded files (octal), like: `511` or `0o755`. Default: 0644\n                            * @param config.parentDirPermissions {Number}  - [Server] Permissions which will be set to parent directory of uploaded files (octal), like: `611` or `0o777`. Default: 0755\n                            * @param config.storagePath    {String|Function}  - [Server] Storage path on file system\n                            * @param config.cacheControl   {String}  - [Server] Default `Cache-Control` header\n                            * @param config.responseHeaders {Object|Function} - [Server] Custom response headers, if function is passed, must return Object\n                            * @param config.throttle       {Number}  - [Server] DEPRECATED bps throttle threshold\n                            * @param config.downloadRoute  {String}  - [Both]   Server Route used to retrieve files\n                            * @param config.collection     {Mongo.Collection} - [Both] Mongo Collection Instance\n                            * @param config.collectionName {String}  - [Both]   Collection name\n                            * @param config.namingFunction {Function}- [Both]   Function which returns `String`\n                            * @param config.integrityCheck {Boolean} - [Server] Check file's integrity before serving to users\n                            * @param config.onAfterUpload  {Function}- [Server] Called right after file is ready on FS. Use to transfer file somewhere else, or do other thing with file directly\n                            * @param config.onAfterRemove  {Function} - [Server] Called right after file is removed. Removed objects is passed to callback\n                            * @param config.continueUploadTTL {Number} - [Server] Time in seconds, during upload may be continued, default 3 hours (10800 seconds)\n                            * @param config.onBeforeUpload {Function}- [Both]   Function which executes on server after receiving each chunk and on client right before beginning upload. Function context is `File` - so you are able to check for extension, mime-type, size and etc.:\n                            *  - return `true` to continue\n                            *  - return `false` or `String` to abort upload\n                            * @param config.onInitiateUpload {Function} - [Server] Function which executes on server right before upload is begin and right after `onBeforeUpload` hook. This hook is fully asynchronous.\n                            * @param config.onBeforeRemove {Function} - [Server] Executes before removing file on server, so you can check permissions. Return `true` to allow action and `false` to deny.\n                            * @param config.allowClientCode  {Boolean}  - [Both]   Allow to run `remove` from client\n                            * @param config.downloadCallback {Function} - [Server] Callback triggered each time file is requested, return truthy value to continue download, or falsy to abort\n                            * @param config.interceptDownload {Function} - [Server] Intercept download request, so you can serve file from third-party resource, arguments {http: {request: {...}, response: {...}}, fileRef: {...}}\n                            * @param config.disableUpload {Boolean} - Disable file upload, useful for server only solutions\n                            * @param config.disableDownload {Boolean} - Disable file download (serving), useful for file management only solutions\n                            * @summary Create new instance of FilesCollection\n                            */\n\nvar FilesCollection = function (_FilesCollectionCore) {\n  (0, _inherits3.default)(FilesCollection, _FilesCollectionCore);\n\n  function FilesCollection(config) {\n    (0, _classCallCheck3.default)(this, FilesCollection);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, _FilesCollectionCore.call(this));\n\n    var storagePath = void 0;\n\n    if (config) {\n      storagePath = config.storagePath;\n      _this.debug = config.debug;\n      _this.schema = config.schema;\n      _this.public = config.public;\n      _this.strict = config.strict;\n      _this.chunkSize = config.chunkSize;\n      _this.protected = config.protected;\n      _this.collection = config.collection;\n      _this.permissions = config.permissions;\n      _this.cacheControl = config.cacheControl;\n      _this.downloadRoute = config.downloadRoute;\n      _this.onAfterUpload = config.onAfterUpload;\n      _this.onAfterRemove = config.onAfterRemove;\n      _this.disableUpload = config.disableUpload;\n      _this.onBeforeRemove = config.onBeforeRemove;\n      _this.integrityCheck = config.integrityCheck;\n      _this.collectionName = config.collectionName;\n      _this.onBeforeUpload = config.onBeforeUpload;\n      _this.namingFunction = config.namingFunction;\n      _this.responseHeaders = config.responseHeaders;\n      _this.disableDownload = config.disableDownload;\n      _this.allowClientCode = config.allowClientCode;\n      _this.downloadCallback = config.downloadCallback;\n      _this.onInitiateUpload = config.onInitiateUpload;\n      _this.interceptDownload = config.interceptDownload;\n      _this.continueUploadTTL = config.continueUploadTTL;\n      _this.parentDirPermissions = config.parentDirPermissions;\n    }\n\n    var self = _this;\n    var cookie = new Cookies();\n\n    if (!_.isBoolean(_this.debug)) {\n      _this.debug = false;\n    }\n\n    if (!_.isBoolean(_this.public)) {\n      _this.public = false;\n    }\n\n    if (!_this.protected) {\n      _this.protected = false;\n    }\n\n    if (!_this.chunkSize) {\n      _this.chunkSize = 1024 * 512;\n    }\n\n    _this.chunkSize = Math.floor(_this.chunkSize / 8) * 8;\n\n    if (!_.isString(_this.collectionName) && !_this.collection) {\n      _this.collectionName = 'MeteorUploadFiles';\n    }\n\n    if (!_this.collection) {\n      _this.collection = new Mongo.Collection(_this.collectionName);\n    } else {\n      _this.collectionName = _this.collection._name;\n    }\n\n    _this.collection.filesCollection = _this;\n    check(_this.collectionName, String);\n\n    if (_this.public && !_this.downloadRoute) {\n      throw new Meteor.Error(500, \"[FilesCollection.\" + _this.collectionName + \"]: \\\"downloadRoute\\\" must be precisely provided on \\\"public\\\" collections! Note: \\\"downloadRoute\\\" must be equal or be inside of your web/proxy-server (relative) root.\");\n    }\n\n    if (!_.isString(_this.downloadRoute)) {\n      _this.downloadRoute = '/cdn/storage';\n    }\n\n    _this.downloadRoute = _this.downloadRoute.replace(/\\/$/, '');\n\n    if (!_.isFunction(_this.namingFunction)) {\n      _this.namingFunction = false;\n    }\n\n    if (!_.isFunction(_this.onBeforeUpload)) {\n      _this.onBeforeUpload = false;\n    }\n\n    if (!_.isBoolean(_this.allowClientCode)) {\n      _this.allowClientCode = true;\n    }\n\n    if (!_.isFunction(_this.onInitiateUpload)) {\n      _this.onInitiateUpload = false;\n    }\n\n    if (!_.isFunction(_this.interceptDownload)) {\n      _this.interceptDownload = false;\n    }\n\n    if (!_.isBoolean(_this.strict)) {\n      _this.strict = true;\n    }\n\n    if (!_.isNumber(_this.permissions)) {\n      _this.permissions = parseInt('644', 8);\n    }\n\n    if (!_.isNumber(_this.parentDirPermissions)) {\n      _this.parentDirPermissions = parseInt('755', 8);\n    }\n\n    if (!_.isString(_this.cacheControl)) {\n      _this.cacheControl = 'public, max-age=31536000, s-maxage=31536000';\n    }\n\n    if (!_.isFunction(_this.onAfterUpload)) {\n      _this.onAfterUpload = false;\n    }\n\n    if (!_.isBoolean(_this.disableUpload)) {\n      _this.disableUpload = false;\n    }\n\n    if (!_.isFunction(_this.onAfterRemove)) {\n      _this.onAfterRemove = false;\n    }\n\n    if (!_.isFunction(_this.onBeforeRemove)) {\n      _this.onBeforeRemove = false;\n    }\n\n    if (!_.isBoolean(_this.integrityCheck)) {\n      _this.integrityCheck = true;\n    }\n\n    if (!_.isBoolean(_this.disableDownload)) {\n      _this.disableDownload = false;\n    }\n\n    if (!_.isObject(_this._currentUploads)) {\n      _this._currentUploads = {};\n    }\n\n    if (!_.isFunction(_this.downloadCallback)) {\n      _this.downloadCallback = false;\n    }\n\n    if (!_.isNumber(_this.continueUploadTTL)) {\n      _this.continueUploadTTL = 10800;\n    }\n\n    if (!_.isFunction(_this.responseHeaders)) {\n      _this.responseHeaders = function (responseCode, fileRef, versionRef) {\n        var headers = {};\n\n        switch (responseCode) {\n          case '206':\n            headers.Pragma = 'private';\n            headers.Trailer = 'expires';\n            headers['Transfer-Encoding'] = 'chunked';\n            break;\n\n          case '400':\n            headers['Cache-Control'] = 'no-cache';\n            break;\n\n          case '416':\n            headers['Content-Range'] = \"bytes */\" + versionRef.size;\n            break;\n\n          default:\n            break;\n        }\n\n        headers.Connection = 'keep-alive';\n        headers['Content-Type'] = versionRef.type || 'application/octet-stream';\n        headers['Accept-Ranges'] = 'bytes';\n        return headers;\n      };\n    }\n\n    if (_this.public && !storagePath) {\n      throw new Meteor.Error(500, \"[FilesCollection.\" + _this.collectionName + \"] \\\"storagePath\\\" must be set on \\\"public\\\" collections! Note: \\\"storagePath\\\" must be equal on be inside of your web/proxy-server (absolute) root.\");\n    }\n\n    if (!storagePath) {\n      storagePath = function () {\n        return \"assets\" + nodePath.sep + \"app\" + nodePath.sep + \"uploads\" + nodePath.sep + self.collectionName;\n      };\n    }\n\n    if (_.isString(storagePath)) {\n      _this.storagePath = function () {\n        return storagePath;\n      };\n    } else {\n      _this.storagePath = function () {\n        var sp = storagePath.apply(self, arguments);\n\n        if (!_.isString(sp)) {\n          throw new Meteor.Error(400, \"[FilesCollection.\" + self.collectionName + \"] \\\"storagePath\\\" function must return a String!\");\n        }\n\n        sp = sp.replace(/\\/$/, '');\n        return nodePath.normalize(sp);\n      };\n    }\n\n    _this._debug('[FilesCollection.storagePath] Set to:', _this.storagePath({}));\n\n    fs.mkdirs(_this.storagePath({}), {\n      mode: _this.parentDirPermissions\n    }, function (error) {\n      if (error) {\n        throw new Meteor.Error(401, \"[FilesCollection.\" + self.collectionName + \"] Path \\\"\" + _this.storagePath({}) + \"\\\" is not writable!\", error);\n      }\n    });\n    check(_this.strict, Boolean);\n    check(_this.permissions, Number);\n    check(_this.storagePath, Function);\n    check(_this.cacheControl, String);\n    check(_this.onAfterRemove, Match.OneOf(false, Function));\n    check(_this.onAfterUpload, Match.OneOf(false, Function));\n    check(_this.disableUpload, Boolean);\n    check(_this.integrityCheck, Boolean);\n    check(_this.onBeforeRemove, Match.OneOf(false, Function));\n    check(_this.disableDownload, Boolean);\n    check(_this.downloadCallback, Match.OneOf(false, Function));\n    check(_this.interceptDownload, Match.OneOf(false, Function));\n    check(_this.continueUploadTTL, Number);\n    check(_this.responseHeaders, Match.OneOf(Object, Function));\n\n    if (!_this.disableUpload) {\n      _this._preCollection = new Mongo.Collection(\"__pre_\" + _this.collectionName);\n\n      _this._preCollection._ensureIndex({\n        createdAt: 1\n      }, {\n        expireAfterSeconds: _this.continueUploadTTL,\n        background: true\n      });\n\n      var _preCollectionCursor = _this._preCollection.find({}, {\n        fields: {\n          _id: 1,\n          isFinished: 1\n        }\n      });\n\n      _preCollectionCursor.observe({\n        changed: function (doc) {\n          if (doc.isFinished) {\n            self._debug(\"[FilesCollection] [_preCollectionCursor.observe] [changed]: \" + doc._id);\n\n            self._preCollection.remove({\n              _id: doc._id\n            }, NOOP);\n          }\n        },\n        removed: function (doc) {\n          // Free memory after upload is done\n          // Or if upload is unfinished\n          self._debug(\"[FilesCollection] [_preCollectionCursor.observe] [removed]: \" + doc._id);\n\n          if (_.isObject(self._currentUploads[doc._id])) {\n            self._currentUploads[doc._id].stop();\n\n            self._currentUploads[doc._id].end();\n\n            if (!doc.isFinished) {\n              self._debug(\"[FilesCollection] [_preCollectionCursor.observe] [removeUnfinishedUpload]: \" + doc._id);\n\n              self._currentUploads[doc._id].abort();\n            }\n\n            delete self._currentUploads[doc._id];\n          }\n        }\n      });\n\n      _this._createStream = function (_id, path, opts) {\n        _this._currentUploads[_id] = new WriteStream(path, opts.fileLength, opts, _this.permissions);\n      }; // This little function allows to continue upload\n      // even after server is restarted (*not on dev-stage*)\n\n\n      _this._continueUpload = function (_id) {\n        if (_this._currentUploads[_id] && _this._currentUploads[_id].file) {\n          if (!_this._currentUploads[_id].aborted && !_this._currentUploads[_id].ended) {\n            return _this._currentUploads[_id].file;\n          }\n\n          _this._createStream(_id, _this._currentUploads[_id].file.file.path, _this._currentUploads[_id].file);\n\n          return _this._currentUploads[_id].file;\n        }\n\n        var contUpld = _this._preCollection.findOne({\n          _id: _id\n        });\n\n        if (contUpld) {\n          _this._createStream(_id, contUpld.file.path, contUpld);\n\n          return _this._currentUploads[_id].file;\n        }\n\n        return false;\n      };\n    }\n\n    if (!_this.schema) {\n      _this.schema = FilesCollectionCore.schema;\n    }\n\n    check(_this.debug, Boolean);\n    check(_this.schema, Object);\n    check(_this.public, Boolean);\n    check(_this.protected, Match.OneOf(Boolean, Function));\n    check(_this.chunkSize, Number);\n    check(_this.downloadRoute, String);\n    check(_this.namingFunction, Match.OneOf(false, Function));\n    check(_this.onBeforeUpload, Match.OneOf(false, Function));\n    check(_this.onInitiateUpload, Match.OneOf(false, Function));\n    check(_this.allowClientCode, Boolean);\n\n    if (_this.public && _this.protected) {\n      throw new Meteor.Error(500, \"[FilesCollection.\" + _this.collectionName + \"]: Files can not be public and protected at the same time!\");\n    }\n\n    _this._checkAccess = function (http) {\n      if (_this.protected) {\n        var result = void 0;\n\n        var _this$_getUser = _this._getUser(http),\n            user = _this$_getUser.user,\n            userId = _this$_getUser.userId;\n\n        if (_.isFunction(_this.protected)) {\n          var fileRef = void 0;\n\n          if (_.isObject(http.params) && http.params._id) {\n            fileRef = _this.collection.findOne(http.params._id);\n          }\n\n          result = http ? _this.protected.call(_.extend(http, {\n            user: user,\n            userId: userId\n          }), fileRef || null) : _this.protected.call({\n            user: user,\n            userId: userId\n          }, fileRef || null);\n        } else {\n          result = !!userId;\n        }\n\n        if (http && result === true || !http) {\n          return true;\n        }\n\n        var rc = _.isNumber(result) ? result : 401;\n\n        _this._debug('[FilesCollection._checkAccess] WARN: Access denied!');\n\n        if (http) {\n          var text = 'Access denied!';\n\n          if (!http.response.headersSent) {\n            http.response.writeHead(rc, {\n              'Content-Type': 'text/plain',\n              'Content-Length': text.length\n            });\n          }\n\n          if (!http.response.finished) {\n            http.response.end(text);\n          }\n        }\n\n        return false;\n      }\n\n      return true;\n    };\n\n    _this._methodNames = {\n      _Abort: \"_FilesCollectionAbort_\" + _this.collectionName,\n      _Write: \"_FilesCollectionWrite_\" + _this.collectionName,\n      _Start: \"_FilesCollectionStart_\" + _this.collectionName,\n      _Remove: \"_FilesCollectionRemove_\" + _this.collectionName\n    };\n\n    _this.on('_handleUpload', _this._handleUpload);\n\n    _this.on('_finishUpload', _this._finishUpload);\n\n    if (!_this.disableUpload && !_this.disableDownload) {\n      WebApp.connectHandlers.use(function (httpReq, httpResp, next) {\n        if (!_this.disableUpload && !!~httpReq._parsedUrl.path.indexOf(_this.downloadRoute + \"/\" + _this.collectionName + \"/__upload\")) {\n          if (httpReq.method === 'POST') {\n            var handleError = function (_error) {\n              var error = _error;\n              console.warn('[FilesCollection] [Upload] [HTTP] Exception:', error);\n              console.trace();\n\n              if (!httpResp.headersSent) {\n                httpResp.writeHead(500);\n              }\n\n              if (!httpResp.finished) {\n                if (_.isObject(error) && _.isFunction(error.toString)) {\n                  error = error.toString();\n                }\n\n                if (!_.isString(error)) {\n                  error = 'Unexpected error!';\n                }\n\n                httpResp.end(JSON.stringify({\n                  error: error\n                }));\n              }\n            };\n\n            var body = '';\n            httpReq.on('data', function (data) {\n              return bound(function () {\n                body += data;\n              });\n            });\n            httpReq.on('end', function () {\n              return bound(function () {\n                try {\n                  var opts = void 0;\n                  var result = void 0;\n                  var user = void 0;\n\n                  if (httpReq.headers['x-mtok'] && _.isObject(Meteor.server.sessions) && _.has(Meteor.server.sessions[httpReq.headers['x-mtok']], 'userId')) {\n                    user = {\n                      userId: Meteor.server.sessions[httpReq.headers['x-mtok']].userId\n                    };\n                  } else {\n                    user = _this._getUser({\n                      request: httpReq,\n                      response: httpResp\n                    });\n                  }\n\n                  if (httpReq.headers['x-start'] !== '1') {\n                    opts = {\n                      fileId: httpReq.headers['x-fileid']\n                    };\n\n                    if (httpReq.headers['x-eof'] === '1') {\n                      opts.eof = true;\n                    } else {\n                      if (typeof Buffer.from === 'function') {\n                        try {\n                          opts.binData = Buffer.from(body, 'base64');\n                        } catch (buffErr) {\n                          opts.binData = new Buffer(body, 'base64');\n                        }\n                      } else {\n                        opts.binData = new Buffer(body, 'base64');\n                      }\n\n                      opts.chunkId = parseInt(httpReq.headers['x-chunkid']);\n                    }\n\n                    var _continueUpload = _this._continueUpload(opts.fileId);\n\n                    if (!_continueUpload) {\n                      throw new Meteor.Error(408, 'Can\\'t continue upload, session expired. Start upload again.');\n                    }\n\n                    var _this$_prepareUpload = _this._prepareUpload(_.extend(opts, _continueUpload), user.userId, 'HTTP');\n\n                    result = _this$_prepareUpload.result;\n                    opts = _this$_prepareUpload.opts;\n\n                    if (opts.eof) {\n                      _this._handleUpload(result, opts, function () {\n                        if (!httpResp.headersSent) {\n                          httpResp.writeHead(200);\n                        }\n\n                        if (_.isObject(result.file) && result.file.meta) {\n                          result.file.meta = fixJSONStringify(result.file.meta);\n                        }\n\n                        if (!httpResp.finished) {\n                          httpResp.end(JSON.stringify(result));\n                        }\n                      });\n\n                      return;\n                    }\n\n                    _this.emit('_handleUpload', result, opts, NOOP);\n\n                    if (!httpResp.headersSent) {\n                      httpResp.writeHead(204);\n                    }\n\n                    if (!httpResp.finished) {\n                      httpResp.end();\n                    }\n                  } else {\n                    try {\n                      opts = JSON.parse(body);\n                    } catch (jsonErr) {\n                      console.error('Can\\'t parse incoming JSON from Client on [.insert() | upload], something went wrong!', jsonErr);\n                      opts = {\n                        file: {}\n                      };\n                    }\n\n                    if (!_.isObject(opts.file)) {\n                      opts.file = {};\n                    }\n\n                    opts.___s = true;\n\n                    _this._debug(\"[FilesCollection] [File Start HTTP] \" + (opts.file.name || '[no-name]') + \" - \" + opts.fileId);\n\n                    if (_.isObject(opts.file) && opts.file.meta) {\n                      opts.file.meta = fixJSONParse(opts.file.meta);\n                    }\n\n                    var _this$_prepareUpload2 = _this._prepareUpload(_.clone(opts), user.userId, 'HTTP Start Method');\n\n                    result = _this$_prepareUpload2.result;\n\n                    if (_this.collection.findOne(result._id)) {\n                      throw new Meteor.Error(400, 'Can\\'t start upload, data substitution detected!');\n                    }\n\n                    opts._id = opts.fileId;\n                    opts.createdAt = new Date();\n                    opts.maxLength = opts.fileLength;\n\n                    _this._preCollection.insert(_.omit(opts, '___s'));\n\n                    _this._createStream(result._id, result.path, _.omit(opts, '___s'));\n\n                    if (opts.returnMeta) {\n                      if (!httpResp.headersSent) {\n                        httpResp.writeHead(200);\n                      }\n\n                      if (!httpResp.finished) {\n                        httpResp.end(JSON.stringify({\n                          uploadRoute: _this.downloadRoute + \"/\" + _this.collectionName + \"/__upload\",\n                          file: result\n                        }));\n                      }\n                    } else {\n                      if (!httpResp.headersSent) {\n                        httpResp.writeHead(204);\n                      }\n\n                      if (!httpResp.finished) {\n                        httpResp.end();\n                      }\n                    }\n                  }\n                } catch (httpRespErr) {\n                  handleError(httpRespErr);\n                }\n              });\n            });\n          } else {\n            next();\n          }\n\n          return;\n        }\n\n        if (!_this.disableDownload) {\n          var http = void 0;\n          var params = void 0;\n          var uri = void 0;\n          var uris = void 0;\n\n          if (!_this.public) {\n            if (!!~httpReq._parsedUrl.path.indexOf(_this.downloadRoute + \"/\" + _this.collectionName)) {\n              uri = httpReq._parsedUrl.path.replace(_this.downloadRoute + \"/\" + _this.collectionName, '');\n\n              if (uri.indexOf('/') === 0) {\n                uri = uri.substring(1);\n              }\n\n              uris = uri.split('/');\n\n              if (uris.length === 3) {\n                params = {\n                  _id: uris[0],\n                  query: httpReq._parsedUrl.query ? nodeQs.parse(httpReq._parsedUrl.query) : {},\n                  name: uris[2].split('?')[0],\n                  version: uris[1]\n                };\n                http = {\n                  request: httpReq,\n                  response: httpResp,\n                  params: params\n                };\n\n                if (_this._checkAccess(http)) {\n                  _this.download(http, uris[1], _this.collection.findOne(uris[0]));\n                }\n              } else {\n                next();\n              }\n            } else {\n              next();\n            }\n          } else {\n            if (!!~httpReq._parsedUrl.path.indexOf(\"\" + _this.downloadRoute)) {\n              uri = httpReq._parsedUrl.path.replace(\"\" + _this.downloadRoute, '');\n\n              if (uri.indexOf('/') === 0) {\n                uri = uri.substring(1);\n              }\n\n              uris = uri.split('/');\n              var _file = uris[uris.length - 1];\n\n              if (_file) {\n                var version = void 0;\n\n                if (!!~_file.indexOf('-')) {\n                  version = _file.split('-')[0];\n                  _file = _file.split('-')[1].split('?')[0];\n                } else {\n                  version = 'original';\n                  _file = _file.split('?')[0];\n                }\n\n                params = {\n                  query: httpReq._parsedUrl.query ? nodeQs.parse(httpReq._parsedUrl.query) : {},\n                  file: _file,\n                  _id: _file.split('.')[0],\n                  version: version,\n                  name: _file\n                };\n                http = {\n                  request: httpReq,\n                  response: httpResp,\n                  params: params\n                };\n\n                _this.download(http, version, _this.collection.findOne(params._id));\n              } else {\n                next();\n              }\n            } else {\n              next();\n            }\n          }\n\n          return;\n        }\n\n        next();\n      });\n    }\n\n    if (!_this.disableUpload) {\n      var _methods = {}; // Method used to remove file\n      // from Client side\n\n      _methods[_this._methodNames._Remove] = function (selector) {\n        check(selector, Match.OneOf(String, Object));\n\n        self._debug(\"[FilesCollection] [Unlink Method] [.remove(\" + selector + \")]\");\n\n        if (self.allowClientCode) {\n          if (self.onBeforeRemove && _.isFunction(self.onBeforeRemove)) {\n            var userId = this.userId;\n            var userFuncs = {\n              userId: this.userId,\n              user: function () {\n                if (Meteor.users) {\n                  return Meteor.users.findOne(userId);\n                }\n\n                return null;\n              }\n            };\n\n            if (!self.onBeforeRemove.call(userFuncs, self.find(selector) || null)) {\n              throw new Meteor.Error(403, '[FilesCollection] [remove] Not permitted!');\n            }\n          }\n\n          var cursor = self.find(selector);\n\n          if (cursor.count() > 0) {\n            self.remove(selector);\n            return true;\n          }\n\n          throw new Meteor.Error(404, 'Cursor is empty, no files is removed');\n        } else {\n          throw new Meteor.Error(401, '[FilesCollection] [remove] Run code from client is not allowed!');\n        }\n      }; // Method used to receive \"first byte\" of upload\n      // and all file's meta-data, so\n      // it won't be transferred with every chunk\n      // Basically it prepares everything\n      // So user can pause/disconnect and\n      // continue upload later, during `continueUploadTTL`\n\n\n      _methods[_this._methodNames._Start] = function (opts, returnMeta) {\n        check(opts, {\n          file: Object,\n          fileId: String,\n          FSName: Match.Optional(String),\n          chunkSize: Number,\n          fileLength: Number\n        });\n        check(returnMeta, Match.Optional(Boolean));\n\n        self._debug(\"[FilesCollection] [File Start Method] \" + opts.file.name + \" - \" + opts.fileId);\n\n        opts.___s = true;\n\n        var _self$_prepareUpload = self._prepareUpload(_.clone(opts), this.userId, 'DDP Start Method'),\n            result = _self$_prepareUpload.result;\n\n        if (self.collection.findOne(result._id)) {\n          throw new Meteor.Error(400, 'Can\\'t start upload, data substitution detected!');\n        }\n\n        opts._id = opts.fileId;\n        opts.createdAt = new Date();\n        opts.maxLength = opts.fileLength;\n\n        self._preCollection.insert(_.omit(opts, '___s'));\n\n        self._createStream(result._id, result.path, _.omit(opts, '___s'));\n\n        if (returnMeta) {\n          return {\n            uploadRoute: self.downloadRoute + \"/\" + self.collectionName + \"/__upload\",\n            file: result\n          };\n        }\n\n        return true;\n      }; // Method used to write file chunks\n      // it receives very limited amount of meta-data\n      // This method also responsible for EOF\n\n\n      _methods[_this._methodNames._Write] = function (opts) {\n        var result = void 0;\n        check(opts, {\n          eof: Match.Optional(Boolean),\n          fileId: String,\n          binData: Match.Optional(String),\n          chunkId: Match.Optional(Number)\n        });\n\n        if (opts.binData) {\n          if (typeof Buffer.from === 'function') {\n            try {\n              opts.binData = Buffer.from(opts.binData, 'base64');\n            } catch (buffErr) {\n              opts.binData = new Buffer(opts.binData, 'base64');\n            }\n          } else {\n            opts.binData = new Buffer(opts.binData, 'base64');\n          }\n        }\n\n        var _continueUpload = self._continueUpload(opts.fileId);\n\n        if (!_continueUpload) {\n          throw new Meteor.Error(408, 'Can\\'t continue upload, session expired. Start upload again.');\n        }\n\n        this.unblock();\n\n        var _self$_prepareUpload2 = self._prepareUpload(_.extend(opts, _continueUpload), this.userId, 'DDP');\n\n        result = _self$_prepareUpload2.result;\n        opts = _self$_prepareUpload2.opts;\n\n        if (opts.eof) {\n          try {\n            return Meteor.wrapAsync(self._handleUpload.bind(self, result, opts))();\n          } catch (handleUploadErr) {\n            self._debug('[FilesCollection] [Write Method] [DDP] Exception:', handleUploadErr);\n\n            throw handleUploadErr;\n          }\n        } else {\n          self.emit('_handleUpload', result, opts, NOOP);\n        }\n\n        return true;\n      }; // Method used to Abort upload\n      // - Feeing memory by .end()ing writableStreams\n      // - Removing temporary record from @_preCollection\n      // - Removing record from @collection\n      // - .unlink()ing chunks from FS\n\n\n      _methods[_this._methodNames._Abort] = function (_id) {\n        check(_id, String);\n\n        var _continueUpload = self._continueUpload(_id);\n\n        self._debug(\"[FilesCollection] [Abort Method]: \" + _id + \" - \" + (_.isObject(_continueUpload.file) ? _continueUpload.file.path : ''));\n\n        if (self._currentUploads && self._currentUploads[_id]) {\n          self._currentUploads[_id].stop();\n\n          self._currentUploads[_id].abort();\n        }\n\n        if (_continueUpload) {\n          self._preCollection.remove({\n            _id: _id\n          });\n\n          self.remove({\n            _id: _id\n          });\n\n          if (_.isObject(_continueUpload.file) && _continueUpload.file.path) {\n            self.unlink({\n              _id: _id,\n              path: _continueUpload.file.path\n            });\n          }\n        }\n\n        return true;\n      };\n\n      Meteor.methods(_methods);\n    }\n\n    return _this;\n  } /*\n     * @locus Server\n     * @memberOf FilesCollection\n     * @name _prepareUpload\n     * @summary Internal method. Used to optimize received data and check upload permission\n     * @returns {Object}\n     */\n\n  FilesCollection.prototype._prepareUpload = function () {\n    function _prepareUpload() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var userId = arguments[1];\n      var transport = arguments[2];\n      var ctx = void 0;\n\n      if (!_.isBoolean(opts.eof)) {\n        opts.eof = false;\n      }\n\n      if (!opts.binData) {\n        opts.binData = 'EOF';\n      }\n\n      if (!_.isNumber(opts.chunkId)) {\n        opts.chunkId = -1;\n      }\n\n      if (!_.isString(opts.FSName)) {\n        opts.FSName = opts.fileId;\n      }\n\n      this._debug(\"[FilesCollection] [Upload] [\" + transport + \"] Got #\" + opts.chunkId + \"/\" + opts.fileLength + \" chunks, dst: \" + (opts.file.name || opts.file.fileName));\n\n      var fileName = this._getFileName(opts.file);\n\n      var _getExt = this._getExt(fileName),\n          extension = _getExt.extension,\n          extensionWithDot = _getExt.extensionWithDot;\n\n      if (!_.isObject(opts.file.meta)) {\n        opts.file.meta = {};\n      }\n\n      var result = opts.file;\n      result.name = fileName;\n      result.meta = opts.file.meta;\n      result.extension = extension;\n      result.ext = extension;\n      result._id = opts.fileId;\n      result.userId = userId || null;\n      opts.FSName = opts.FSName.replace(/([^a-z0-9\\-\\_]+)/gi, '-');\n      result.path = \"\" + this.storagePath(result) + nodePath.sep + opts.FSName + extensionWithDot;\n      result = _.extend(result, this._dataToSchema(result));\n\n      if (this.onBeforeUpload && _.isFunction(this.onBeforeUpload)) {\n        ctx = _.extend({\n          file: opts.file\n        }, {\n          chunkId: opts.chunkId,\n          userId: result.userId,\n          user: function () {\n            if (Meteor.users && result.userId) {\n              return Meteor.users.findOne(result.userId);\n            }\n\n            return null;\n          },\n          eof: opts.eof\n        });\n        var isUploadAllowed = this.onBeforeUpload.call(ctx, result);\n\n        if (isUploadAllowed !== true) {\n          throw new Meteor.Error(403, _.isString(isUploadAllowed) ? isUploadAllowed : '@onBeforeUpload() returned false');\n        } else {\n          if (opts.___s === true && this.onInitiateUpload && _.isFunction(this.onInitiateUpload)) {\n            this.onInitiateUpload.call(ctx, result);\n          }\n        }\n      } else if (opts.___s === true && this.onInitiateUpload && _.isFunction(this.onInitiateUpload)) {\n        ctx = _.extend({\n          file: opts.file\n        }, {\n          chunkId: opts.chunkId,\n          userId: result.userId,\n          user: function () {\n            if (Meteor.users && result.userId) {\n              return Meteor.users.findOne(result.userId);\n            }\n\n            return null;\n          },\n          eof: opts.eof\n        });\n        this.onInitiateUpload.call(ctx, result);\n      }\n\n      return {\n        result: result,\n        opts: opts\n      };\n    }\n\n    return _prepareUpload;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name _finishUpload\n        * @summary Internal method. Finish upload, close Writable stream, add record to MongoDB and flush used memory\n        * @returns {undefined}\n        */\n\n  FilesCollection.prototype._finishUpload = function () {\n    function _finishUpload(result, opts, cb) {\n      var _this2 = this;\n\n      this._debug(\"[FilesCollection] [Upload] [finish(ing)Upload] -> \" + result.path);\n\n      fs.chmod(result.path, this.permissions, NOOP);\n      result.type = this._getMimeType(opts.file);\n      result.public = this.public;\n\n      this._updateFileTypes(result);\n\n      this.collection.insert(_.clone(result), function (error, _id) {\n        if (error) {\n          cb && cb(error);\n\n          _this2._debug('[FilesCollection] [Upload] [_finishUpload] Error:', error);\n        } else {\n          _this2._preCollection.update({\n            _id: opts.fileId\n          }, {\n            $set: {\n              isFinished: true\n            }\n          });\n\n          result._id = _id;\n\n          _this2._debug(\"[FilesCollection] [Upload] [finish(ed)Upload] -> \" + result.path);\n\n          _this2.onAfterUpload && _this2.onAfterUpload.call(_this2, result);\n\n          _this2.emit('afterUpload', result);\n\n          cb && cb(null, result);\n        }\n      });\n    }\n\n    return _finishUpload;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name _handleUpload\n        * @summary Internal method to handle upload process, pipe incoming data to Writable stream\n        * @returns {undefined}\n        */\n\n  FilesCollection.prototype._handleUpload = function () {\n    function _handleUpload(result, opts, cb) {\n      var _this3 = this;\n\n      try {\n        if (opts.eof) {\n          this._currentUploads[result._id].end(function () {\n            _this3.emit('_finishUpload', result, opts, cb);\n          });\n        } else {\n          this._currentUploads[result._id].write(opts.chunkId, opts.binData, cb);\n        }\n      } catch (e) {\n        this._debug('[_handleUpload] [EXCEPTION:]', e);\n\n        cb && cb(e);\n      }\n    }\n\n    return _handleUpload;\n  }(); /*\n        * @locus Anywhere\n        * @memberOf FilesCollection\n        * @name _getMimeType\n        * @param {Object} fileData - File Object\n        * @summary Returns file's mime-type\n        * @returns {String}\n        */\n\n  FilesCollection.prototype._getMimeType = function () {\n    function _getMimeType(fileData) {\n      var mime = void 0;\n      check(fileData, Object);\n\n      if (_.isObject(fileData) && fileData.type) {\n        mime = fileData.type;\n      }\n\n      if (fileData.path && (!mime || !_.isString(mime))) {\n        try {\n          var buf = new Buffer(262);\n          var fd = fs.openSync(fileData.path, 'r');\n          var br = fs.readSync(fd, buf, 0, 262, 0);\n          fs.close(fd, NOOP);\n\n          if (br < 262) {\n            buf = buf.slice(0, br);\n          }\n\n          var _fileType = fileType(buf);\n\n          mime = _fileType.mime;\n        } catch (e) {// We're good\n        }\n      }\n\n      if (!mime || !_.isString(mime)) {\n        mime = 'application/octet-stream';\n      }\n\n      return mime;\n    }\n\n    return _getMimeType;\n  }(); /*\n        * @locus Anywhere\n        * @memberOf FilesCollection\n        * @name _getUser\n        * @summary Returns object with `userId` and `user()` method which return user's object\n        * @returns {Object}\n        */\n\n  FilesCollection.prototype._getUser = function () {\n    function _getUser(http) {\n      var result = {\n        user: function () {\n          return null;\n        },\n        userId: null\n      };\n\n      if (http) {\n        var mtok = null;\n\n        if (http.request.headers['x-mtok']) {\n          mtok = http.request.headers['x-mtok'];\n        } else {\n          var cookie = http.request.Cookies;\n\n          if (cookie.has('x_mtok')) {\n            mtok = cookie.get('x_mtok');\n          }\n        }\n\n        if (mtok) {\n          var userId = _.isObject(Meteor.server.sessions) && _.isObject(Meteor.server.sessions[mtok]) ? Meteor.server.sessions[mtok].userId : void 0;\n\n          if (userId) {\n            result.user = function () {\n              return Meteor.users.findOne(userId);\n            };\n\n            result.userId = userId;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    return _getUser;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name write\n        * @param {Buffer} buffer - Binary File's Buffer\n        * @param {Object} opts - Object with file-data\n        * @param {String} opts.name - File name, alias: `fileName`\n        * @param {String} opts.type - File mime-type\n        * @param {Object} opts.meta - File additional meta-data\n        * @param {String} opts.userId - UserId, default *null*\n        * @param {String} opts.fileId - _id, default *null*\n        * @param {Function} callback - function(error, fileObj){...}\n        * @param {Boolean} proceedAfterUpload - Proceed onAfterUpload hook\n        * @summary Write buffer to FS and add to FilesCollection Collection\n        * @returns {FilesCollection} Instance\n        */\n\n  FilesCollection.prototype.write = function () {\n    function write(buffer) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _this4 = this;\n\n      var callback = arguments[2];\n      var proceedAfterUpload = arguments[3];\n\n      this._debug('[FilesCollection] [write()]');\n\n      if (_.isFunction(opts)) {\n        proceedAfterUpload = callback;\n        callback = opts;\n        opts = {};\n      } else if (_.isBoolean(callback)) {\n        proceedAfterUpload = callback;\n      } else if (_.isBoolean(opts)) {\n        proceedAfterUpload = opts;\n      }\n\n      check(opts, Match.Optional(Object));\n      check(callback, Match.Optional(Function));\n      check(proceedAfterUpload, Match.Optional(Boolean));\n      var fileId = opts.fileId || Random.id();\n      var FSName = this.namingFunction ? this.namingFunction(opts) : fileId;\n      var fileName = opts.name || opts.fileName ? opts.name || opts.fileName : FSName;\n\n      var _getExt2 = this._getExt(fileName),\n          extension = _getExt2.extension,\n          extensionWithDot = _getExt2.extensionWithDot;\n\n      opts.path = \"\" + this.storagePath(opts) + nodePath.sep + FSName + extensionWithDot;\n      opts.type = this._getMimeType(opts);\n\n      if (!_.isObject(opts.meta)) {\n        opts.meta = {};\n      }\n\n      if (!_.isNumber(opts.size)) {\n        opts.size = buffer.length;\n      }\n\n      var result = this._dataToSchema({\n        name: fileName,\n        path: opts.path,\n        meta: opts.meta,\n        type: opts.type,\n        size: opts.size,\n        userId: opts.userId,\n        extension: extension\n      });\n\n      result._id = fileId;\n      var stream = fs.createWriteStream(opts.path, {\n        flags: 'w',\n        mode: this.permissions\n      });\n      stream.end(buffer, function (streamErr) {\n        return bound(function () {\n          if (streamErr) {\n            callback && callback(streamErr);\n          } else {\n            _this4.collection.insert(result, function (insertErr, _id) {\n              if (insertErr) {\n                callback && callback(insertErr);\n\n                _this4._debug(\"[FilesCollection] [write] [insert] Error: \" + fileName + \" -> \" + _this4.collectionName, insertErr);\n              } else {\n                var fileRef = _this4.collection.findOne(_id);\n\n                callback && callback(null, fileRef);\n\n                if (proceedAfterUpload === true) {\n                  _this4.onAfterUpload && _this4.onAfterUpload.call(_this4, fileRef);\n\n                  _this4.emit('afterUpload', fileRef);\n                }\n\n                _this4._debug(\"[FilesCollection] [write]: \" + fileName + \" -> \" + _this4.collectionName);\n              }\n            });\n          }\n        });\n      });\n      return this;\n    }\n\n    return write;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name load\n        * @param {String} url - URL to file\n        * @param {Object} opts - Object with file-data\n        * @param {Object} opts.headers - HTTP headers to use when requesting the file\n        * @param {String} opts.name - File name, alias: `fileName`\n        * @param {String} opts.type - File mime-type\n        * @param {Object} opts.meta - File additional meta-data\n        * @param {String} opts.userId - UserId, default *null*\n        * @param {String} opts.fileId - _id, default *null*\n        * @param {Function} callback - function(error, fileObj){...}\n        * @param {Boolean} proceedAfterUpload - Proceed onAfterUpload hook\n        * @summary Download file, write stream to FS and add to FilesCollection Collection\n        * @returns {FilesCollection} Instance\n        */\n\n  FilesCollection.prototype.load = function () {\n    function load(url) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _this5 = this;\n\n      var callback = arguments[2];\n      var proceedAfterUpload = arguments[3];\n\n      this._debug(\"[FilesCollection] [load(\" + url + \", \" + JSON.stringify(opts) + \", callback)]\");\n\n      if (_.isFunction(opts)) {\n        proceedAfterUpload = callback;\n        callback = opts;\n        opts = {};\n      } else if (_.isBoolean(callback)) {\n        proceedAfterUpload = callback;\n      } else if (_.isBoolean(opts)) {\n        proceedAfterUpload = opts;\n      }\n\n      check(url, String);\n      check(opts, Match.Optional(Object));\n      check(callback, Match.Optional(Function));\n      check(proceedAfterUpload, Match.Optional(Boolean));\n\n      if (!_.isObject(opts)) {\n        opts = {};\n      }\n\n      var fileId = opts.fileId || Random.id();\n      var FSName = this.namingFunction ? this.namingFunction(opts) : fileId;\n      var pathParts = url.split('/');\n      var fileName = opts.name || opts.fileName ? opts.name || opts.fileName : pathParts[pathParts.length - 1] || FSName;\n\n      var _getExt3 = this._getExt(fileName),\n          extension = _getExt3.extension,\n          extensionWithDot = _getExt3.extensionWithDot;\n\n      opts.path = \"\" + this.storagePath(opts) + nodePath.sep + FSName + extensionWithDot;\n\n      var storeResult = function (result, cb) {\n        result._id = fileId;\n\n        _this5.collection.insert(result, function (error, _id) {\n          if (error) {\n            cb && cb(error);\n\n            _this5._debug(\"[FilesCollection] [load] [insert] Error: \" + fileName + \" -> \" + _this5.collectionName, error);\n          } else {\n            var fileRef = _this5.collection.findOne(_id);\n\n            cb && cb(null, fileRef);\n\n            if (proceedAfterUpload === true) {\n              _this5.onAfterUpload && _this5.onAfterUpload.call(_this5, fileRef);\n\n              _this5.emit('afterUpload', fileRef);\n            }\n\n            _this5._debug(\"[FilesCollection] [load] [insert] \" + fileName + \" -> \" + _this5.collectionName);\n          }\n        });\n      };\n\n      request.get({\n        url: url,\n        headers: opts.headers || {}\n      }).on('error', function (error) {\n        return bound(function () {\n          callback && callback(error);\n\n          _this5._debug(\"[FilesCollection] [load] [request.get(\" + url + \")] Error:\", error);\n        });\n      }).on('response', function (response) {\n        return bound(function () {\n          response.on('end', function () {\n            return bound(function () {\n              _this5._debug(\"[FilesCollection] [load] Received: \" + url);\n\n              var result = _this5._dataToSchema({\n                name: fileName,\n                path: opts.path,\n                meta: opts.meta,\n                type: opts.type || response.headers['content-type'] || _this5._getMimeType({\n                  path: opts.path\n                }),\n                size: opts.size || parseInt(response.headers['content-length'] || 0),\n                userId: opts.userId,\n                extension: extension\n              });\n\n              if (!result.size) {\n                fs.stat(opts.path, function (error, stats) {\n                  return bound(function () {\n                    if (error) {\n                      callback && callback(error);\n                    } else {\n                      result.versions.original.size = result.size = stats.size;\n                      storeResult(result, callback);\n                    }\n                  });\n                });\n              } else {\n                storeResult(result, callback);\n              }\n            });\n          });\n        });\n      }).pipe(fs.createWriteStream(opts.path, {\n        flags: 'w',\n        mode: this.permissions\n      }));\n      return this;\n    }\n\n    return load;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name addFile\n        * @param {String} path          - Path to file\n        * @param {String} opts          - [Optional] Object with file-data\n        * @param {String} opts.type     - [Optional] File mime-type\n        * @param {Object} opts.meta     - [Optional] File additional meta-data\n        * @param {String} opts.fileId   - _id, default *null*\n        * @param {Object} opts.fileName - [Optional] File name, if not specified file name and extension will be taken from path\n        * @param {String} opts.userId   - [Optional] UserId, default *null*\n        * @param {Function} callback    - [Optional] function(error, fileObj){...}\n        * @param {Boolean} proceedAfterUpload - Proceed onAfterUpload hook\n        * @summary Add file from FS to FilesCollection\n        * @returns {FilesCollection} Instance\n        */\n\n  FilesCollection.prototype.addFile = function () {\n    function addFile(path) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _this6 = this;\n\n      var callback = arguments[2];\n      var proceedAfterUpload = arguments[3];\n\n      this._debug(\"[FilesCollection] [addFile(\" + path + \")]\");\n\n      if (_.isFunction(opts)) {\n        proceedAfterUpload = callback;\n        callback = opts;\n        opts = {};\n      } else if (_.isBoolean(callback)) {\n        proceedAfterUpload = callback;\n      } else if (_.isBoolean(opts)) {\n        proceedAfterUpload = opts;\n      }\n\n      if (this.public) {\n        throw new Meteor.Error(403, 'Can not run [addFile] on public collection! Just Move file to root of your server, then add record to Collection');\n      }\n\n      check(path, String);\n      check(opts, Match.Optional(Object));\n      check(callback, Match.Optional(Function));\n      check(proceedAfterUpload, Match.Optional(Boolean));\n      fs.stat(path, function (statErr, stats) {\n        return bound(function () {\n          if (statErr) {\n            callback && callback(statErr);\n          } else if (stats.isFile()) {\n            if (!_.isObject(opts)) {\n              opts = {};\n            }\n\n            opts.path = path;\n\n            if (!opts.fileName) {\n              var pathParts = path.split(nodePath.sep);\n              opts.fileName = path.split(nodePath.sep)[pathParts.length - 1];\n            }\n\n            var _getExt4 = _this6._getExt(opts.fileName),\n                extension = _getExt4.extension;\n\n            if (!_.isString(opts.type)) {\n              opts.type = _this6._getMimeType(opts);\n            }\n\n            if (!_.isObject(opts.meta)) {\n              opts.meta = {};\n            }\n\n            if (!_.isNumber(opts.size)) {\n              opts.size = stats.size;\n            }\n\n            var result = _this6._dataToSchema({\n              name: opts.fileName,\n              path: path,\n              meta: opts.meta,\n              type: opts.type,\n              size: opts.size,\n              userId: opts.userId,\n              extension: extension,\n              _storagePath: path.replace(\"\" + nodePath.sep + opts.fileName, ''),\n              fileId: opts.fileId || null\n            });\n\n            _this6.collection.insert(result, function (insertErr, _id) {\n              if (insertErr) {\n                callback && callback(insertErr);\n\n                _this6._debug(\"[FilesCollection] [addFile] [insert] Error: \" + result.name + \" -> \" + _this6.collectionName, insertErr);\n              } else {\n                var fileRef = _this6.collection.findOne(_id);\n\n                callback && callback(null, fileRef);\n\n                if (proceedAfterUpload === true) {\n                  _this6.onAfterUpload && _this6.onAfterUpload.call(_this6, fileRef);\n\n                  _this6.emit('afterUpload', fileRef);\n                }\n\n                _this6._debug(\"[FilesCollection] [addFile]: \" + result.name + \" -> \" + _this6.collectionName);\n              }\n            });\n          } else {\n            callback && callback(new Meteor.Error(400, \"[FilesCollection] [addFile(\" + path + \")]: File does not exist\"));\n          }\n        });\n      });\n      return this;\n    }\n\n    return addFile;\n  }(); /*\n        * @locus Anywhere\n        * @memberOf FilesCollection\n        * @name remove\n        * @param {String|Object} selector - Mongo-Style selector (http://docs.meteor.com/api/collections.html#selectors)\n        * @param {Function} callback - Callback with one `error` argument\n        * @summary Remove documents from the collection\n        * @returns {FilesCollection} Instance\n        */\n\n  FilesCollection.prototype.remove = function () {\n    function remove(selector, callback) {\n      var _this7 = this;\n\n      this._debug(\"[FilesCollection] [remove(\" + JSON.stringify(selector) + \")]\");\n\n      if (selector === undefined) {\n        return 0;\n      }\n\n      check(callback, Match.Optional(Function));\n      var files = this.collection.find(selector);\n\n      if (files.count() > 0) {\n        files.forEach(function (file) {\n          _this7.unlink(file);\n        });\n      } else {\n        callback && callback(new Meteor.Error(404, 'Cursor is empty, no files is removed'));\n        return this;\n      }\n\n      if (this.onAfterRemove) {\n        var docs = files.fetch();\n        var self = this;\n        this.collection.remove(selector, function () {\n          callback && callback.apply(this, arguments);\n          self.onAfterRemove(docs);\n        });\n      } else {\n        this.collection.remove(selector, callback || NOOP);\n      }\n\n      return this;\n    }\n\n    return remove;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name deny\n        * @param {Object} rules\n        * @see  https://docs.meteor.com/api/collections.html#Mongo-Collection-deny\n        * @summary link Mongo.Collection deny methods\n        * @returns {Mongo.Collection} Instance\n        */\n\n  FilesCollection.prototype.deny = function () {\n    function deny(rules) {\n      this.collection.deny(rules);\n      return this.collection;\n    }\n\n    return deny;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name allow\n        * @param {Object} rules\n        * @see https://docs.meteor.com/api/collections.html#Mongo-Collection-allow\n        * @summary link Mongo.Collection allow methods\n        * @returns {Mongo.Collection} Instance\n        */\n\n  FilesCollection.prototype.allow = function () {\n    function allow(rules) {\n      this.collection.allow(rules);\n      return this.collection;\n    }\n\n    return allow;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name denyClient\n        * @see https://docs.meteor.com/api/collections.html#Mongo-Collection-deny\n        * @summary Shorthands for Mongo.Collection deny method\n        * @returns {Mongo.Collection} Instance\n        */\n\n  FilesCollection.prototype.denyClient = function () {\n    function denyClient() {\n      this.collection.deny({\n        insert: function () {\n          return true;\n        },\n        update: function () {\n          return true;\n        },\n        remove: function () {\n          return true;\n        }\n      });\n      return this.collection;\n    }\n\n    return denyClient;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name allowClient\n        * @see https://docs.meteor.com/api/collections.html#Mongo-Collection-allow\n        * @summary Shorthands for Mongo.Collection allow method\n        * @returns {Mongo.Collection} Instance\n        */\n\n  FilesCollection.prototype.allowClient = function () {\n    function allowClient() {\n      this.collection.allow({\n        insert: function () {\n          return true;\n        },\n        update: function () {\n          return true;\n        },\n        remove: function () {\n          return true;\n        }\n      });\n      return this.collection;\n    }\n\n    return allowClient;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name unlink\n        * @param {Object} fileRef - fileObj\n        * @param {String} version - [Optional] file's version\n        * @param {Function} callback - [Optional] callback function\n        * @summary Unlink files and it's versions from FS\n        * @returns {FilesCollection} Instance\n        */\n\n  FilesCollection.prototype.unlink = function () {\n    function unlink(fileRef, version, callback) {\n      this._debug(\"[FilesCollection] [unlink(\" + fileRef._id + \", \" + version + \")]\");\n\n      if (version) {\n        if (_.isObject(fileRef.versions) && _.isObject(fileRef.versions[version]) && fileRef.versions[version].path) {\n          fs.unlink(fileRef.versions[version].path, callback || NOOP);\n        }\n      } else {\n        if (_.isObject(fileRef.versions)) {\n          _.each(fileRef.versions, function (vRef) {\n            return bound(function () {\n              fs.unlink(vRef.path, callback || NOOP);\n            });\n          });\n        } else {\n          fs.unlink(fileRef.path, callback || NOOP);\n        }\n      }\n\n      return this;\n    }\n\n    return unlink;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name _404\n        * @summary Internal method, used to return 404 error\n        * @returns {undefined}\n        */\n\n  FilesCollection.prototype._404 = function () {\n    function _404(http) {\n      this._debug(\"[FilesCollection] [download(\" + http.request.originalUrl + \")] [_404] File not found\");\n\n      var text = 'File Not Found :(';\n\n      if (!http.response.headersSent) {\n        http.response.writeHead(404, {\n          'Content-Type': 'text/plain',\n          'Content-Length': text.length\n        });\n      }\n\n      if (!http.response.finished) {\n        http.response.end(text);\n      }\n    }\n\n    return _404;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name download\n        * @param {Object} http    - Server HTTP object\n        * @param {String} version - Requested file version\n        * @param {Object} fileRef - Requested file Object\n        * @summary Initiates the HTTP response\n        * @returns {undefined}\n        */\n\n  FilesCollection.prototype.download = function () {\n    function download(http) {\n      var _this8 = this;\n\n      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'original';\n      var fileRef = arguments[2];\n      var vRef = void 0;\n\n      this._debug(\"[FilesCollection] [download(\" + http.request.originalUrl + \", \" + version + \")]\");\n\n      if (fileRef) {\n        if (_.has(fileRef, 'versions') && _.has(fileRef.versions, version)) {\n          vRef = fileRef.versions[version];\n          vRef._id = fileRef._id;\n        } else {\n          vRef = fileRef;\n        }\n      } else {\n        vRef = false;\n      }\n\n      if (!vRef || !_.isObject(vRef)) {\n        return this._404(http);\n      } else if (fileRef) {\n        if (this.downloadCallback) {\n          if (!this.downloadCallback.call(_.extend(http, this._getUser(http)), fileRef)) {\n            return this._404(http);\n          }\n        }\n\n        if (this.interceptDownload && _.isFunction(this.interceptDownload)) {\n          if (this.interceptDownload(http, fileRef, version) === true) {\n            return void 0;\n          }\n        }\n\n        fs.stat(vRef.path, function (statErr, stats) {\n          return bound(function () {\n            var responseType = void 0;\n\n            if (statErr || !stats.isFile()) {\n              return _this8._404(http);\n            }\n\n            if (stats.size !== vRef.size && !_this8.integrityCheck) {\n              vRef.size = stats.size;\n            }\n\n            if (stats.size !== vRef.size && _this8.integrityCheck) {\n              responseType = '400';\n            }\n\n            return _this8.serve(http, fileRef, vRef, version, null, responseType || '200');\n          });\n        });\n        return void 0;\n      }\n\n      return this._404(http);\n    }\n\n    return download;\n  }(); /*\n        * @locus Server\n        * @memberOf FilesCollection\n        * @name serve\n        * @param {Object} http    - Server HTTP object\n        * @param {Object} fileRef - Requested file Object\n        * @param {Object} vRef    - Requested file version Object\n        * @param {String} version - Requested file version\n        * @param {stream.Readable|null} readableStream - Readable stream, which serves binary file data\n        * @param {String} responseType - Response code\n        * @param {Boolean} force200 - Force 200 response code over 206\n        * @summary Handle and reply to incoming request\n        * @returns {undefined}\n        */\n\n  FilesCollection.prototype.serve = function () {\n    function serve(http, fileRef, vRef) {\n      var version = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'original';\n      var readableStream = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n      var _this9 = this;\n\n      var responseType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '200';\n      var force200 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      var partiral = false;\n      var reqRange = false;\n      var dispositionType = '';\n      var start = void 0;\n      var end = void 0;\n      var take = void 0;\n\n      if (http.params.query.download && http.params.query.download === 'true') {\n        dispositionType = 'attachment; ';\n      } else {\n        dispositionType = 'inline; ';\n      }\n\n      var dispositionName = \"filename=\\\"\" + encodeURI(vRef.name || fileRef.name) + \"\\\"; filename*=UTF-8''\" + encodeURI(vRef.name || fileRef.name) + \"; \";\n      var dispositionEncoding = 'charset=UTF-8';\n\n      if (!http.response.headersSent) {\n        http.response.setHeader('Content-Disposition', dispositionType + dispositionName + dispositionEncoding);\n      }\n\n      if (http.request.headers.range && !force200) {\n        partiral = true;\n        var array = http.request.headers.range.split(/bytes=([0-9]*)-([0-9]*)/);\n        start = parseInt(array[1]);\n        end = parseInt(array[2]);\n\n        if (isNaN(end)) {\n          end = vRef.size - 1;\n        }\n\n        take = end - start;\n      } else {\n        start = 0;\n        end = vRef.size - 1;\n        take = vRef.size;\n      }\n\n      if (partiral || http.params.query.play && http.params.query.play === 'true') {\n        reqRange = {\n          start: start,\n          end: end\n        };\n\n        if (isNaN(start) && !isNaN(end)) {\n          reqRange.start = end - take;\n          reqRange.end = end;\n        }\n\n        if (!isNaN(start) && isNaN(end)) {\n          reqRange.start = start;\n          reqRange.end = start + take;\n        }\n\n        if (start + take >= vRef.size) {\n          reqRange.end = vRef.size - 1;\n        }\n\n        if (this.strict && (reqRange.start >= vRef.size - 1 || reqRange.end > vRef.size - 1)) {\n          responseType = '416';\n        } else {\n          responseType = '206';\n        }\n      } else {\n        responseType = '200';\n      }\n\n      var streamErrorHandler = function (error) {\n        _this9._debug(\"[FilesCollection] [serve(\" + vRef.path + \", \" + version + \")] [500]\", error);\n\n        if (!http.response.finished) {\n          http.response.end(error.toString());\n        }\n      };\n\n      var headers = _.isFunction(this.responseHeaders) ? this.responseHeaders(responseType, fileRef, vRef, version) : this.responseHeaders;\n\n      if (!headers['Cache-Control']) {\n        if (!http.response.headersSent) {\n          http.response.setHeader('Cache-Control', this.cacheControl);\n        }\n      }\n\n      for (var key in meteorBabelHelpers.sanitizeForInObject(headers)) {\n        if (!http.response.headersSent) {\n          http.response.setHeader(key, headers[key]);\n        }\n      }\n\n      var respond = function (stream, code) {\n        if (!http.response.headersSent && readableStream) {\n          http.response.writeHead(code);\n        }\n\n        http.response.on('close', function () {\n          if (typeof stream.abort === 'function') {\n            stream.abort();\n          }\n\n          if (typeof stream.end === 'function') {\n            stream.end();\n          }\n        });\n        http.request.on('aborted', function () {\n          http.request.aborted = true;\n\n          if (typeof stream.abort === 'function') {\n            stream.abort();\n          }\n\n          if (typeof stream.end === 'function') {\n            stream.end();\n          }\n        });\n        stream.on('open', function () {\n          if (!http.response.headersSent) {\n            http.response.writeHead(code);\n          }\n        }).on('abort', function () {\n          if (!http.response.finished) {\n            http.response.end();\n          }\n\n          if (!http.request.aborted) {\n            http.request.destroy();\n          }\n        }).on('error', streamErrorHandler).on('end', function () {\n          if (!http.response.finished) {\n            http.response.end();\n          }\n        }).pipe(http.response);\n      };\n\n      switch (responseType) {\n        case '400':\n          this._debug(\"[FilesCollection] [serve(\" + vRef.path + \", \" + version + \")] [400] Content-Length mismatch!\");\n\n          var text = 'Content-Length mismatch!';\n\n          if (!http.response.headersSent) {\n            http.response.writeHead(400, {\n              'Content-Type': 'text/plain',\n              'Content-Length': text.length\n            });\n          }\n\n          if (!http.response.finished) {\n            http.response.end(text);\n          }\n\n          break;\n\n        case '404':\n          this._404(http);\n\n          break;\n\n        case '416':\n          this._debug(\"[FilesCollection] [serve(\" + vRef.path + \", \" + version + \")] [416] Content-Range is not specified!\");\n\n          if (!http.response.headersSent) {\n            http.response.writeHead(416);\n          }\n\n          if (!http.response.finished) {\n            http.response.end();\n          }\n\n          break;\n\n        case '206':\n          this._debug(\"[FilesCollection] [serve(\" + vRef.path + \", \" + version + \")] [206]\");\n\n          if (!http.response.headersSent) {\n            http.response.setHeader('Content-Range', \"bytes \" + reqRange.start + \"-\" + reqRange.end + \"/\" + vRef.size);\n          }\n\n          respond(readableStream || fs.createReadStream(vRef.path, {\n            start: reqRange.start,\n            end: reqRange.end\n          }), 206);\n          break;\n\n        default:\n          this._debug(\"[FilesCollection] [serve(\" + vRef.path + \", \" + version + \")] [200]\");\n\n          respond(readableStream || fs.createReadStream(vRef.path), 200);\n          break;\n      }\n    }\n\n    return serve;\n  }();\n\n  return FilesCollection;\n}(FilesCollectionCore);","map":{"version":3,"sources":["packages/ostrio:files/server.js"],"names":["module","export","FilesCollection","_","watch","require","v","Mongo","WebApp","Meteor","Random","Cookies","WriteStream","check","Match","FilesCollectionCore","fixJSONParse","fixJSONStringify","fs","nodeQs","request","fileType","nodePath","bound","bindEnvironment","callback","NOOP","config","storagePath","debug","schema","public","strict","chunkSize","protected","collection","permissions","cacheControl","downloadRoute","onAfterUpload","onAfterRemove","disableUpload","onBeforeRemove","integrityCheck","collectionName","onBeforeUpload","namingFunction","responseHeaders","disableDownload","allowClientCode","downloadCallback","onInitiateUpload","interceptDownload","continueUploadTTL","parentDirPermissions","self","cookie","isBoolean","Math","floor","isString","Collection","_name","filesCollection","String","Error","replace","isFunction","isNumber","parseInt","isObject","_currentUploads","responseCode","fileRef","versionRef","headers","Pragma","Trailer","size","Connection","type","sep","sp","apply","arguments","normalize","_debug","mkdirs","mode","error","Boolean","Number","Function","OneOf","Object","_preCollection","_ensureIndex","createdAt","expireAfterSeconds","background","_preCollectionCursor","find","fields","_id","isFinished","observe","changed","doc","remove","removed","stop","end","abort","_createStream","path","opts","fileLength","_continueUpload","file","aborted","ended","contUpld","findOne","_checkAccess","http","result","_getUser","user","userId","params","call","extend","rc","text","response","headersSent","writeHead","length","finished","_methodNames","_Abort","_Write","_Start","_Remove","on","_handleUpload","_finishUpload","connectHandlers","use","httpReq","httpResp","next","_parsedUrl","indexOf","method","handleError","_error","console","warn","trace","toString","JSON","stringify","body","data","server","sessions","has","fileId","eof","Buffer","from","binData","buffErr","chunkId","_prepareUpload","meta","emit","parse","jsonErr","___s","name","clone","Date","maxLength","insert","omit","returnMeta","uploadRoute","httpRespErr","uri","uris","substring","split","query","version","download","_file","_methods","selector","userFuncs","users","cursor","count","FSName","Optional","unblock","wrapAsync","bind","handleUploadErr","unlink","methods","transport","ctx","fileName","_getFileName","_getExt","extension","extensionWithDot","ext","_dataToSchema","isUploadAllowed","cb","chmod","_getMimeType","_updateFileTypes","update","$set","write","e","fileData","mime","buf","fd","openSync","br","readSync","close","slice","mtok","get","buffer","proceedAfterUpload","id","stream","createWriteStream","flags","streamErr","insertErr","load","url","pathParts","storeResult","stat","stats","versions","original","pipe","addFile","statErr","isFile","_storagePath","undefined","files","forEach","docs","fetch","deny","rules","allow","denyClient","allowClient","each","vRef","_404","originalUrl","responseType","serve","readableStream","force200","partiral","reqRange","dispositionType","start","take","dispositionName","encodeURI","dispositionEncoding","setHeader","range","array","isNaN","play","streamErrorHandler","key","respond","code","destroy","createReadStream"],"mappings":"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","file":"packages/ostrio:files/server.js.map","sourcesContent":["import { _ }                              from 'meteor/underscore';\nimport { Mongo }                          from 'meteor/mongo';\nimport { WebApp }                         from 'meteor/webapp';\nimport { Meteor }                         from 'meteor/meteor';\nimport { Random }                         from 'meteor/random';\nimport { Cookies }                        from 'meteor/ostrio:cookies';\nimport WriteStream                        from './write-stream.js';\nimport { check, Match }                   from 'meteor/check';\nimport FilesCollectionCore                from './core.js';\nimport { fixJSONParse, fixJSONStringify } from './lib.js';\n\nimport fs       from 'fs-extra';\nimport nodeQs   from 'querystring';\nimport request  from 'request';\nimport fileType from 'file-type';\nimport nodePath from 'path';\n\n/*\n * @const {Object} bound  - Meteor.bindEnvironment (Fiber wrapper)\n * @const {Function} NOOP - No Operation function, placeholder for required callbacks\n */\nconst bound = Meteor.bindEnvironment(callback => callback());\nconst NOOP  = () => {  };\n\n/*\n * @locus Anywhere\n * @class FilesCollection\n * @param config           {Object}   - [Both]   Configuration object with next properties:\n * @param config.debug     {Boolean}  - [Both]   Turn on/of debugging and extra logging\n * @param config.schema    {Object}   - [Both]   Collection Schema\n * @param config.public    {Boolean}  - [Both]   Store files in folder accessible for proxy servers, for limits, and more - read docs\n * @param config.strict    {Boolean}  - [Server] Strict mode for partial content, if is `true` server will return `416` response code, when `range` is not specified, otherwise server return `206`\n * @param config.protected {Function} - [Server] If `true` - files will be served only to authorized users, if `function()` - you're able to check visitor's permissions in your own way function's context has:\n *  - `request`\n *  - `response`\n *  - `user()`\n *  - `userId`\n * @param config.chunkSize      {Number}  - [Both] Upload chunk size, default: 524288 bytes (0,5 Mb)\n * @param config.permissions    {Number}  - [Server] Permissions which will be set to uploaded files (octal), like: `511` or `0o755`. Default: 0644\n * @param config.parentDirPermissions {Number}  - [Server] Permissions which will be set to parent directory of uploaded files (octal), like: `611` or `0o777`. Default: 0755\n * @param config.storagePath    {String|Function}  - [Server] Storage path on file system\n * @param config.cacheControl   {String}  - [Server] Default `Cache-Control` header\n * @param config.responseHeaders {Object|Function} - [Server] Custom response headers, if function is passed, must return Object\n * @param config.throttle       {Number}  - [Server] DEPRECATED bps throttle threshold\n * @param config.downloadRoute  {String}  - [Both]   Server Route used to retrieve files\n * @param config.collection     {Mongo.Collection} - [Both] Mongo Collection Instance\n * @param config.collectionName {String}  - [Both]   Collection name\n * @param config.namingFunction {Function}- [Both]   Function which returns `String`\n * @param config.integrityCheck {Boolean} - [Server] Check file's integrity before serving to users\n * @param config.onAfterUpload  {Function}- [Server] Called right after file is ready on FS. Use to transfer file somewhere else, or do other thing with file directly\n * @param config.onAfterRemove  {Function} - [Server] Called right after file is removed. Removed objects is passed to callback\n * @param config.continueUploadTTL {Number} - [Server] Time in seconds, during upload may be continued, default 3 hours (10800 seconds)\n * @param config.onBeforeUpload {Function}- [Both]   Function which executes on server after receiving each chunk and on client right before beginning upload. Function context is `File` - so you are able to check for extension, mime-type, size and etc.:\n *  - return `true` to continue\n *  - return `false` or `String` to abort upload\n * @param config.onInitiateUpload {Function} - [Server] Function which executes on server right before upload is begin and right after `onBeforeUpload` hook. This hook is fully asynchronous.\n * @param config.onBeforeRemove {Function} - [Server] Executes before removing file on server, so you can check permissions. Return `true` to allow action and `false` to deny.\n * @param config.allowClientCode  {Boolean}  - [Both]   Allow to run `remove` from client\n * @param config.downloadCallback {Function} - [Server] Callback triggered each time file is requested, return truthy value to continue download, or falsy to abort\n * @param config.interceptDownload {Function} - [Server] Intercept download request, so you can serve file from third-party resource, arguments {http: {request: {...}, response: {...}}, fileRef: {...}}\n * @param config.disableUpload {Boolean} - Disable file upload, useful for server only solutions\n * @param config.disableDownload {Boolean} - Disable file download (serving), useful for file management only solutions\n * @summary Create new instance of FilesCollection\n */\nexport class FilesCollection extends FilesCollectionCore {\n  constructor(config) {\n    super();\n    let storagePath;\n    if (config) {\n      ({\n        storagePath,\n        debug: this.debug,\n        schema: this.schema,\n        public: this.public,\n        strict: this.strict,\n        chunkSize: this.chunkSize,\n        protected: this.protected,\n        collection: this.collection,\n        permissions: this.permissions,\n        cacheControl: this.cacheControl,\n        downloadRoute: this.downloadRoute,\n        onAfterUpload: this.onAfterUpload,\n        onAfterRemove: this.onAfterRemove,\n        disableUpload: this.disableUpload,\n        onBeforeRemove: this.onBeforeRemove,\n        integrityCheck: this.integrityCheck,\n        collectionName: this.collectionName,\n        onBeforeUpload: this.onBeforeUpload,\n        namingFunction: this.namingFunction,\n        responseHeaders: this.responseHeaders,\n        disableDownload: this.disableDownload,\n        allowClientCode: this.allowClientCode,\n        downloadCallback: this.downloadCallback,\n        onInitiateUpload: this.onInitiateUpload,\n        interceptDownload: this.interceptDownload,\n        continueUploadTTL: this.continueUploadTTL,\n        parentDirPermissions: this.parentDirPermissions\n      } = config);\n    }\n\n    const self   = this;\n    const cookie = new Cookies();\n\n    if (!_.isBoolean(this.debug)) {\n      this.debug = false;\n    }\n\n    if (!_.isBoolean(this.public)) {\n      this.public = false;\n    }\n\n    if (!this.protected) {\n      this.protected = false;\n    }\n\n    if (!this.chunkSize) {\n      this.chunkSize = 1024 * 512;\n    }\n\n    this.chunkSize = Math.floor(this.chunkSize / 8) * 8;\n\n    if (!_.isString(this.collectionName) && !this.collection) {\n      this.collectionName = 'MeteorUploadFiles';\n    }\n\n    if (!this.collection) {\n      this.collection = new Mongo.Collection(this.collectionName);\n    } else {\n      this.collectionName = this.collection._name;\n    }\n\n    this.collection.filesCollection = this;\n    check(this.collectionName, String);\n\n    if (this.public && !this.downloadRoute) {\n      throw new Meteor.Error(500, `[FilesCollection.${this.collectionName}]: \\\"downloadRoute\\\" must be precisely provided on \\\"public\\\" collections! Note: \\\"downloadRoute\\\" must be equal or be inside of your web/proxy-server (relative) root.`);\n    }\n\n    if (!_.isString(this.downloadRoute)) {\n      this.downloadRoute = '/cdn/storage';\n    }\n\n    this.downloadRoute = this.downloadRoute.replace(/\\/$/, '');\n\n    if (!_.isFunction(this.namingFunction)) {\n      this.namingFunction = false;\n    }\n\n    if (!_.isFunction(this.onBeforeUpload)) {\n      this.onBeforeUpload = false;\n    }\n\n    if (!_.isBoolean(this.allowClientCode)) {\n      this.allowClientCode = true;\n    }\n\n    if (!_.isFunction(this.onInitiateUpload)) {\n      this.onInitiateUpload = false;\n    }\n\n    if (!_.isFunction(this.interceptDownload)) {\n      this.interceptDownload = false;\n    }\n\n    if (!_.isBoolean(this.strict)) {\n      this.strict = true;\n    }\n\n    if (!_.isNumber(this.permissions)) {\n      this.permissions = parseInt('644', 8);\n    }\n\n    if (!_.isNumber(this.parentDirPermissions)) {\n      this.parentDirPermissions = parseInt('755', 8);\n    }\n\n    if (!_.isString(this.cacheControl)) {\n      this.cacheControl = 'public, max-age=31536000, s-maxage=31536000';\n    }\n\n    if (!_.isFunction(this.onAfterUpload)) {\n      this.onAfterUpload = false;\n    }\n\n    if (!_.isBoolean(this.disableUpload)) {\n      this.disableUpload = false;\n    }\n\n    if (!_.isFunction(this.onAfterRemove)) {\n      this.onAfterRemove = false;\n    }\n\n    if (!_.isFunction(this.onBeforeRemove)) {\n      this.onBeforeRemove = false;\n    }\n\n    if (!_.isBoolean(this.integrityCheck)) {\n      this.integrityCheck = true;\n    }\n\n    if (!_.isBoolean(this.disableDownload)) {\n      this.disableDownload = false;\n    }\n\n    if (!_.isObject(this._currentUploads)) {\n      this._currentUploads = {};\n    }\n\n    if (!_.isFunction(this.downloadCallback)) {\n      this.downloadCallback = false;\n    }\n\n    if (!_.isNumber(this.continueUploadTTL)) {\n      this.continueUploadTTL = 10800;\n    }\n\n    if (!_.isFunction(this.responseHeaders)) {\n      this.responseHeaders = (responseCode, fileRef, versionRef) => {\n        const headers = {};\n\n        switch (responseCode) {\n        case '206':\n          headers.Pragma               = 'private';\n          headers.Trailer              = 'expires';\n          headers['Transfer-Encoding'] = 'chunked';\n          break;\n        case '400':\n          headers['Cache-Control']     = 'no-cache';\n          break;\n        case '416':\n          headers['Content-Range']     = `bytes */${versionRef.size}`;\n          break;\n        default:\n          break;\n        }\n\n        headers.Connection       = 'keep-alive';\n        headers['Content-Type']  = versionRef.type || 'application/octet-stream';\n        headers['Accept-Ranges'] = 'bytes';\n        return headers;\n      };\n    }\n\n    if (this.public && !storagePath) {\n      throw new Meteor.Error(500, `[FilesCollection.${this.collectionName}] \\\"storagePath\\\" must be set on \\\"public\\\" collections! Note: \\\"storagePath\\\" must be equal on be inside of your web/proxy-server (absolute) root.`);\n    }\n\n    if (!storagePath) {\n      storagePath = function () {\n        return `assets${nodePath.sep}app${nodePath.sep}uploads${nodePath.sep}${self.collectionName}`;\n      };\n    }\n\n    if (_.isString(storagePath)) {\n      this.storagePath = () => storagePath;\n    } else {\n      this.storagePath = function () {\n        let sp = storagePath.apply(self, arguments);\n        if (!_.isString(sp)) {\n          throw new Meteor.Error(400, `[FilesCollection.${self.collectionName}] \\\"storagePath\\\" function must return a String!`);\n        }\n        sp = sp.replace(/\\/$/, '');\n        return nodePath.normalize(sp);\n      };\n    }\n\n    this._debug('[FilesCollection.storagePath] Set to:', this.storagePath({}));\n\n    fs.mkdirs(this.storagePath({}), { mode: this.parentDirPermissions }, (error) => {\n      if (error) {\n        throw new Meteor.Error(401, `[FilesCollection.${self.collectionName}] Path \\\"${this.storagePath({})}\\\" is not writable!`, error);\n      }\n    });\n\n    check(this.strict, Boolean);\n    check(this.permissions, Number);\n    check(this.storagePath, Function);\n    check(this.cacheControl, String);\n    check(this.onAfterRemove, Match.OneOf(false, Function));\n    check(this.onAfterUpload, Match.OneOf(false, Function));\n    check(this.disableUpload, Boolean);\n    check(this.integrityCheck, Boolean);\n    check(this.onBeforeRemove, Match.OneOf(false, Function));\n    check(this.disableDownload, Boolean);\n    check(this.downloadCallback, Match.OneOf(false, Function));\n    check(this.interceptDownload, Match.OneOf(false, Function));\n    check(this.continueUploadTTL, Number);\n    check(this.responseHeaders, Match.OneOf(Object, Function));\n\n    if (!this.disableUpload) {\n      this._preCollection = new Mongo.Collection(`__pre_${this.collectionName}`);\n      this._preCollection._ensureIndex({createdAt: 1}, {expireAfterSeconds: this.continueUploadTTL, background: true});\n      const _preCollectionCursor = this._preCollection.find({}, {\n        fields: {\n          _id: 1,\n          isFinished: 1\n        }\n      });\n\n      _preCollectionCursor.observe({\n        changed(doc) {\n          if (doc.isFinished) {\n            self._debug(`[FilesCollection] [_preCollectionCursor.observe] [changed]: ${doc._id}`);\n            self._preCollection.remove({_id: doc._id}, NOOP);\n          }\n        },\n        removed(doc) {\n          // Free memory after upload is done\n          // Or if upload is unfinished\n          self._debug(`[FilesCollection] [_preCollectionCursor.observe] [removed]: ${doc._id}`);\n          if (_.isObject(self._currentUploads[doc._id])) {\n            self._currentUploads[doc._id].stop();\n            self._currentUploads[doc._id].end();\n\n            if (!doc.isFinished) {\n              self._debug(`[FilesCollection] [_preCollectionCursor.observe] [removeUnfinishedUpload]: ${doc._id}`);\n              self._currentUploads[doc._id].abort();\n            }\n\n            delete self._currentUploads[doc._id];\n          }\n        }\n      });\n\n      this._createStream = (_id, path, opts) => {\n        this._currentUploads[_id] = new WriteStream(path, opts.fileLength, opts, this.permissions);\n      };\n\n      // This little function allows to continue upload\n      // even after server is restarted (*not on dev-stage*)\n      this._continueUpload = (_id) => {\n        if (this._currentUploads[_id] && this._currentUploads[_id].file) {\n          if (!this._currentUploads[_id].aborted && !this._currentUploads[_id].ended) {\n            return this._currentUploads[_id].file;\n          }\n          this._createStream(_id, this._currentUploads[_id].file.file.path, this._currentUploads[_id].file);\n          return this._currentUploads[_id].file;\n        }\n        const contUpld = this._preCollection.findOne({_id});\n        if (contUpld) {\n          this._createStream(_id, contUpld.file.path, contUpld);\n          return this._currentUploads[_id].file;\n        }\n        return false;\n      };\n    }\n\n    if (!this.schema) {\n      this.schema = FilesCollectionCore.schema;\n    }\n\n    check(this.debug, Boolean);\n    check(this.schema, Object);\n    check(this.public, Boolean);\n    check(this.protected, Match.OneOf(Boolean, Function));\n    check(this.chunkSize, Number);\n    check(this.downloadRoute, String);\n    check(this.namingFunction, Match.OneOf(false, Function));\n    check(this.onBeforeUpload, Match.OneOf(false, Function));\n    check(this.onInitiateUpload, Match.OneOf(false, Function));\n    check(this.allowClientCode, Boolean);\n\n    if (this.public && this.protected) {\n      throw new Meteor.Error(500, `[FilesCollection.${this.collectionName}]: Files can not be public and protected at the same time!`);\n    }\n\n    this._checkAccess = (http) => {\n      if (this.protected) {\n        let result;\n        const {user, userId} = this._getUser(http);\n\n        if (_.isFunction(this.protected)) {\n          let fileRef;\n          if (_.isObject(http.params) &&  http.params._id) {\n            fileRef = this.collection.findOne(http.params._id);\n          }\n\n          result = http ? this.protected.call(_.extend(http, {user, userId}), (fileRef || null)) : this.protected.call({user, userId}, (fileRef || null));\n        } else {\n          result = !!userId;\n        }\n\n        if ((http && (result === true)) || !http) {\n          return true;\n        }\n\n        const rc = _.isNumber(result) ? result : 401;\n        this._debug('[FilesCollection._checkAccess] WARN: Access denied!');\n        if (http) {\n          const text = 'Access denied!';\n          if (!http.response.headersSent) {\n            http.response.writeHead(rc, {\n              'Content-Type': 'text/plain',\n              'Content-Length': text.length\n            });\n          }\n\n          if (!http.response.finished) {\n            http.response.end(text);\n          }\n        }\n\n        return false;\n      }\n      return true;\n    };\n\n    this._methodNames = {\n      _Abort: `_FilesCollectionAbort_${this.collectionName}`,\n      _Write: `_FilesCollectionWrite_${this.collectionName}`,\n      _Start: `_FilesCollectionStart_${this.collectionName}`,\n      _Remove: `_FilesCollectionRemove_${this.collectionName}`\n    };\n\n    this.on('_handleUpload', this._handleUpload);\n    this.on('_finishUpload', this._finishUpload);\n\n    if (!this.disableUpload && !this.disableDownload) {\n      WebApp.connectHandlers.use((httpReq, httpResp, next) => {\n        if (!this.disableUpload && !!~httpReq._parsedUrl.path.indexOf(`${this.downloadRoute}/${this.collectionName}/__upload`)) {\n          if (httpReq.method === 'POST') {\n            const handleError = (_error) => {\n              let error = _error;\n              console.warn('[FilesCollection] [Upload] [HTTP] Exception:', error);\n              console.trace();\n\n              if (!httpResp.headersSent) {\n                httpResp.writeHead(500);\n              }\n\n              if (!httpResp.finished) {\n                if (_.isObject(error) && _.isFunction(error.toString)) {\n                  error = error.toString();\n                }\n\n                if (!_.isString(error)) {\n                  error = 'Unexpected error!';\n                }\n\n                httpResp.end(JSON.stringify({ error }));\n              }\n            };\n\n            let body = '';\n            httpReq.on('data', (data) => bound(() => {\n              body += data;\n            }));\n\n            httpReq.on('end', () => bound(() => {\n              try {\n                let opts;\n                let result;\n                let user;\n\n                if (httpReq.headers['x-mtok'] && _.isObject(Meteor.server.sessions) && _.has(Meteor.server.sessions[httpReq.headers['x-mtok']], 'userId')) {\n                  user = {\n                    userId: Meteor.server.sessions[httpReq.headers['x-mtok']].userId\n                  };\n                } else {\n                  user = this._getUser({request: httpReq, response: httpResp});\n                }\n\n                if (httpReq.headers['x-start'] !== '1') {\n                  opts = {\n                    fileId: httpReq.headers['x-fileid']\n                  };\n\n                  if (httpReq.headers['x-eof'] === '1') {\n                    opts.eof = true;\n                  } else {\n                    if (typeof Buffer.from === 'function') {\n                      try {\n                        opts.binData = Buffer.from(body, 'base64');\n                      } catch (buffErr) {\n                        opts.binData = new Buffer(body, 'base64');\n                      }\n                    } else {\n                      opts.binData = new Buffer(body, 'base64');\n                    }\n                    opts.chunkId = parseInt(httpReq.headers['x-chunkid']);\n                  }\n\n                  const _continueUpload = this._continueUpload(opts.fileId);\n                  if (!_continueUpload) {\n                    throw new Meteor.Error(408, 'Can\\'t continue upload, session expired. Start upload again.');\n                  }\n\n                  ({result, opts}  = this._prepareUpload(_.extend(opts, _continueUpload), user.userId, 'HTTP'));\n\n                  if (opts.eof) {\n                    this._handleUpload(result, opts, () => {\n                      if (!httpResp.headersSent) {\n                        httpResp.writeHead(200);\n                      }\n\n                      if (_.isObject(result.file) && result.file.meta) {\n                        result.file.meta = fixJSONStringify(result.file.meta);\n                      }\n\n                      if (!httpResp.finished) {\n                        httpResp.end(JSON.stringify(result));\n                      }\n                    });\n                    return;\n                  }\n\n                  this.emit('_handleUpload', result, opts, NOOP);\n\n                  if (!httpResp.headersSent) {\n                    httpResp.writeHead(204);\n                  }\n                  if (!httpResp.finished) {\n                    httpResp.end();\n                  }\n                } else {\n                  try {\n                    opts = JSON.parse(body);\n                  } catch (jsonErr) {\n                    console.error('Can\\'t parse incoming JSON from Client on [.insert() | upload], something went wrong!', jsonErr);\n                    opts = {file: {}};\n                  }\n\n                  if (!_.isObject(opts.file)) {\n                    opts.file = {};\n                  }\n\n                  opts.___s = true;\n                  this._debug(`[FilesCollection] [File Start HTTP] ${opts.file.name || '[no-name]'} - ${opts.fileId}`);\n                  if (_.isObject(opts.file) && opts.file.meta) {\n                    opts.file.meta = fixJSONParse(opts.file.meta);\n                  }\n\n                  ({result} = this._prepareUpload(_.clone(opts), user.userId, 'HTTP Start Method'));\n\n                  if (this.collection.findOne(result._id)) {\n                    throw new Meteor.Error(400, 'Can\\'t start upload, data substitution detected!');\n                  }\n\n                  opts._id       = opts.fileId;\n                  opts.createdAt = new Date();\n                  opts.maxLength = opts.fileLength;\n                  this._preCollection.insert(_.omit(opts, '___s'));\n                  this._createStream(result._id, result.path, _.omit(opts, '___s'));\n\n                  if (opts.returnMeta) {\n                    if (!httpResp.headersSent) {\n                      httpResp.writeHead(200);\n                    }\n\n                    if (!httpResp.finished) {\n                      httpResp.end(JSON.stringify({\n                        uploadRoute: `${this.downloadRoute}/${this.collectionName}/__upload`,\n                        file: result\n                      }));\n                    }\n                  } else {\n                    if (!httpResp.headersSent) {\n                      httpResp.writeHead(204);\n                    }\n\n                    if (!httpResp.finished) {\n                      httpResp.end();\n                    }\n                  }\n                }\n              } catch (httpRespErr) {\n                handleError(httpRespErr);\n              }\n            }));\n          } else {\n            next();\n          }\n          return;\n        }\n\n        if (!this.disableDownload) {\n          let http;\n          let params;\n          let uri;\n          let uris;\n\n          if (!this.public) {\n            if (!!~httpReq._parsedUrl.path.indexOf(`${this.downloadRoute}/${this.collectionName}`)) {\n              uri = httpReq._parsedUrl.path.replace(`${this.downloadRoute}/${this.collectionName}`, '');\n              if (uri.indexOf('/') === 0) {\n                uri = uri.substring(1);\n              }\n\n              uris = uri.split('/');\n              if (uris.length === 3) {\n                params = {\n                  _id: uris[0],\n                  query: httpReq._parsedUrl.query ? nodeQs.parse(httpReq._parsedUrl.query) : {},\n                  name: uris[2].split('?')[0],\n                  version: uris[1]\n                };\n\n                http = {request: httpReq, response: httpResp, params};\n                if (this._checkAccess(http)) {\n                  this.download(http, uris[1], this.collection.findOne(uris[0]));\n                }\n              } else {\n                next();\n              }\n            } else {\n              next();\n            }\n          } else {\n            if (!!~httpReq._parsedUrl.path.indexOf(`${this.downloadRoute}`)) {\n              uri = httpReq._parsedUrl.path.replace(`${this.downloadRoute}`, '');\n              if (uri.indexOf('/') === 0) {\n                uri = uri.substring(1);\n              }\n\n              uris  = uri.split('/');\n              let _file = uris[uris.length - 1];\n              if (_file) {\n                let version;\n                if (!!~_file.indexOf('-')) {\n                  version = _file.split('-')[0];\n                  _file   = _file.split('-')[1].split('?')[0];\n                } else {\n                  version = 'original';\n                  _file   = _file.split('?')[0];\n                }\n\n                params = {\n                  query: httpReq._parsedUrl.query ? nodeQs.parse(httpReq._parsedUrl.query) : {},\n                  file: _file,\n                  _id: _file.split('.')[0],\n                  version,\n                  name: _file\n                };\n                http = {request: httpReq, response: httpResp, params};\n                this.download(http, version, this.collection.findOne(params._id));\n              } else {\n                next();\n              }\n            } else {\n              next();\n            }\n          }\n          return;\n        }\n        next();\n      });\n    }\n\n    if (!this.disableUpload) {\n      const _methods = {};\n\n      // Method used to remove file\n      // from Client side\n      _methods[this._methodNames._Remove] = function (selector) {\n        check(selector, Match.OneOf(String, Object));\n        self._debug(`[FilesCollection] [Unlink Method] [.remove(${selector})]`);\n\n        if (self.allowClientCode) {\n          if (self.onBeforeRemove && _.isFunction(self.onBeforeRemove)) {\n            const userId = this.userId;\n            const userFuncs = {\n              userId: this.userId,\n              user() {\n                if (Meteor.users) {\n                  return Meteor.users.findOne(userId);\n                }\n                return null;\n              }\n            };\n\n            if (!self.onBeforeRemove.call(userFuncs, (self.find(selector) || null))) {\n              throw new Meteor.Error(403, '[FilesCollection] [remove] Not permitted!');\n            }\n          }\n\n          const cursor = self.find(selector);\n          if (cursor.count() > 0) {\n            self.remove(selector);\n            return true;\n          }\n          throw new Meteor.Error(404, 'Cursor is empty, no files is removed');\n        } else {\n          throw new Meteor.Error(401, '[FilesCollection] [remove] Run code from client is not allowed!');\n        }\n      };\n\n\n      // Method used to receive \"first byte\" of upload\n      // and all file's meta-data, so\n      // it won't be transferred with every chunk\n      // Basically it prepares everything\n      // So user can pause/disconnect and\n      // continue upload later, during `continueUploadTTL`\n      _methods[this._methodNames._Start] = function (opts, returnMeta) {\n        check(opts, {\n          file: Object,\n          fileId: String,\n          FSName: Match.Optional(String),\n          chunkSize: Number,\n          fileLength: Number\n        });\n\n        check(returnMeta, Match.Optional(Boolean));\n\n        self._debug(`[FilesCollection] [File Start Method] ${opts.file.name} - ${opts.fileId}`);\n        opts.___s = true;\n        const { result } = self._prepareUpload(_.clone(opts), this.userId, 'DDP Start Method');\n\n        if (self.collection.findOne(result._id)) {\n          throw new Meteor.Error(400, 'Can\\'t start upload, data substitution detected!');\n        }\n\n        opts._id       = opts.fileId;\n        opts.createdAt = new Date();\n        opts.maxLength = opts.fileLength;\n        self._preCollection.insert(_.omit(opts, '___s'));\n        self._createStream(result._id, result.path, _.omit(opts, '___s'));\n\n        if (returnMeta) {\n          return {\n            uploadRoute: `${self.downloadRoute}/${self.collectionName}/__upload`,\n            file: result\n          };\n        }\n        return true;\n      };\n\n\n      // Method used to write file chunks\n      // it receives very limited amount of meta-data\n      // This method also responsible for EOF\n      _methods[this._methodNames._Write] = function (opts) {\n        let result;\n        check(opts, {\n          eof: Match.Optional(Boolean),\n          fileId: String,\n          binData: Match.Optional(String),\n          chunkId: Match.Optional(Number)\n        });\n\n        if (opts.binData) {\n          if (typeof Buffer.from === 'function') {\n            try {\n              opts.binData = Buffer.from(opts.binData, 'base64');\n            } catch (buffErr) {\n              opts.binData = new Buffer(opts.binData, 'base64');\n            }\n          } else {\n            opts.binData = new Buffer(opts.binData, 'base64');\n          }\n        }\n\n        const _continueUpload = self._continueUpload(opts.fileId);\n        if (!_continueUpload) {\n          throw new Meteor.Error(408, 'Can\\'t continue upload, session expired. Start upload again.');\n        }\n\n        this.unblock();\n        ({result, opts} = self._prepareUpload(_.extend(opts, _continueUpload), this.userId, 'DDP'));\n\n        if (opts.eof) {\n          try {\n            return Meteor.wrapAsync(self._handleUpload.bind(self, result, opts))();\n          } catch (handleUploadErr) {\n            self._debug('[FilesCollection] [Write Method] [DDP] Exception:', handleUploadErr);\n            throw handleUploadErr;\n          }\n        } else {\n          self.emit('_handleUpload', result, opts, NOOP);\n        }\n        return true;\n      };\n\n      // Method used to Abort upload\n      // - Feeing memory by .end()ing writableStreams\n      // - Removing temporary record from @_preCollection\n      // - Removing record from @collection\n      // - .unlink()ing chunks from FS\n      _methods[this._methodNames._Abort] = function (_id) {\n        check(_id, String);\n\n        const _continueUpload = self._continueUpload(_id);\n        self._debug(`[FilesCollection] [Abort Method]: ${_id} - ${(_.isObject(_continueUpload.file) ? _continueUpload.file.path : '')}`);\n\n        if (self._currentUploads && self._currentUploads[_id]) {\n          self._currentUploads[_id].stop();\n          self._currentUploads[_id].abort();\n        }\n\n        if (_continueUpload) {\n          self._preCollection.remove({_id});\n          self.remove({_id});\n          if (_.isObject(_continueUpload.file) && _continueUpload.file.path) {\n            self.unlink({_id, path: _continueUpload.file.path});\n          }\n        }\n        return true;\n      };\n\n      Meteor.methods(_methods);\n    }\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name _prepareUpload\n   * @summary Internal method. Used to optimize received data and check upload permission\n   * @returns {Object}\n   */\n  _prepareUpload(opts = {}, userId, transport) {\n    let ctx;\n    if (!_.isBoolean(opts.eof)) {\n      opts.eof = false;\n    }\n\n    if (!opts.binData) {\n      opts.binData = 'EOF';\n    }\n\n    if (!_.isNumber(opts.chunkId)) {\n      opts.chunkId = -1;\n    }\n\n    if (!_.isString(opts.FSName)) {\n      opts.FSName = opts.fileId;\n    }\n\n    this._debug(`[FilesCollection] [Upload] [${transport}] Got #${opts.chunkId}/${opts.fileLength} chunks, dst: ${opts.file.name || opts.file.fileName}`);\n\n    const fileName = this._getFileName(opts.file);\n    const {extension, extensionWithDot} = this._getExt(fileName);\n\n    if (!_.isObject(opts.file.meta)) {\n      opts.file.meta = {};\n    }\n\n    let result       = opts.file;\n    result.name      = fileName;\n    result.meta      = opts.file.meta;\n    result.extension = extension;\n    result.ext       = extension;\n    result._id       = opts.fileId;\n    result.userId    = userId || null;\n    opts.FSName      = opts.FSName.replace(/([^a-z0-9\\-\\_]+)/gi, '-');\n    result.path      = `${this.storagePath(result)}${nodePath.sep}${opts.FSName}${extensionWithDot}`;\n    result           = _.extend(result, this._dataToSchema(result));\n\n    if (this.onBeforeUpload && _.isFunction(this.onBeforeUpload)) {\n      ctx = _.extend({\n        file: opts.file\n      }, {\n        chunkId: opts.chunkId,\n        userId: result.userId,\n        user() {\n          if (Meteor.users && result.userId) {\n            return Meteor.users.findOne(result.userId);\n          }\n          return null;\n        },\n        eof: opts.eof\n      });\n      const isUploadAllowed = this.onBeforeUpload.call(ctx, result);\n\n      if (isUploadAllowed !== true) {\n        throw new Meteor.Error(403, _.isString(isUploadAllowed) ? isUploadAllowed : '@onBeforeUpload() returned false');\n      } else {\n        if ((opts.___s === true) && this.onInitiateUpload && _.isFunction(this.onInitiateUpload)) {\n          this.onInitiateUpload.call(ctx, result);\n        }\n      }\n    } else if ((opts.___s === true) && this.onInitiateUpload && _.isFunction(this.onInitiateUpload)) {\n      ctx = _.extend({\n        file: opts.file\n      }, {\n        chunkId: opts.chunkId,\n        userId: result.userId,\n        user() {\n          if (Meteor.users && result.userId) {\n            return Meteor.users.findOne(result.userId);\n          }\n          return null;\n        },\n        eof: opts.eof\n      });\n      this.onInitiateUpload.call(ctx, result);\n    }\n\n    return {result, opts};\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name _finishUpload\n   * @summary Internal method. Finish upload, close Writable stream, add record to MongoDB and flush used memory\n   * @returns {undefined}\n   */\n  _finishUpload(result, opts, cb) {\n    this._debug(`[FilesCollection] [Upload] [finish(ing)Upload] -> ${result.path}`);\n    fs.chmod(result.path, this.permissions, NOOP);\n    result.type   = this._getMimeType(opts.file);\n    result.public = this.public;\n    this._updateFileTypes(result);\n\n    this.collection.insert(_.clone(result), (error, _id) => {\n      if (error) {\n        cb && cb(error);\n        this._debug('[FilesCollection] [Upload] [_finishUpload] Error:', error);\n      } else {\n        this._preCollection.update({_id: opts.fileId}, {$set: {isFinished: true}});\n        result._id = _id;\n        this._debug(`[FilesCollection] [Upload] [finish(ed)Upload] -> ${result.path}`);\n        this.onAfterUpload && this.onAfterUpload.call(this, result);\n        this.emit('afterUpload', result);\n        cb && cb(null, result);\n      }\n    });\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name _handleUpload\n   * @summary Internal method to handle upload process, pipe incoming data to Writable stream\n   * @returns {undefined}\n   */\n  _handleUpload(result, opts, cb) {\n    try {\n      if (opts.eof) {\n        this._currentUploads[result._id].end(() => {\n          this.emit('_finishUpload', result, opts, cb);\n        });\n      } else {\n        this._currentUploads[result._id].write(opts.chunkId, opts.binData, cb);\n      }\n    } catch (e) {\n      this._debug('[_handleUpload] [EXCEPTION:]', e);\n      cb && cb(e);\n    }\n  }\n\n  /*\n   * @locus Anywhere\n   * @memberOf FilesCollection\n   * @name _getMimeType\n   * @param {Object} fileData - File Object\n   * @summary Returns file's mime-type\n   * @returns {String}\n   */\n  _getMimeType(fileData) {\n    let mime;\n    check(fileData, Object);\n    if (_.isObject(fileData) && fileData.type) {\n      mime = fileData.type;\n    }\n\n    if (fileData.path && (!mime || !_.isString(mime))) {\n      try {\n        let buf   = new Buffer(262);\n        const fd  = fs.openSync(fileData.path, 'r');\n        const br  = fs.readSync(fd, buf, 0, 262, 0);\n        fs.close(fd, NOOP);\n        if (br < 262) {\n          buf = buf.slice(0, br);\n        }\n        ({mime} = fileType(buf));\n      } catch (e) {\n        // We're good\n      }\n    }\n\n    if (!mime || !_.isString(mime)) {\n      mime = 'application/octet-stream';\n    }\n    return mime;\n  }\n\n  /*\n   * @locus Anywhere\n   * @memberOf FilesCollection\n   * @name _getUser\n   * @summary Returns object with `userId` and `user()` method which return user's object\n   * @returns {Object}\n   */\n  _getUser(http) {\n    const result = {\n      user() { return null; },\n      userId: null\n    };\n\n    if (http) {\n      let mtok = null;\n      if (http.request.headers['x-mtok']) {\n        mtok = http.request.headers['x-mtok'];\n      } else {\n        const cookie = http.request.Cookies;\n        if (cookie.has('x_mtok')) {\n          mtok = cookie.get('x_mtok');\n        }\n      }\n\n      if (mtok) {\n        const userId = (_.isObject(Meteor.server.sessions) && _.isObject(Meteor.server.sessions[mtok])) ? Meteor.server.sessions[mtok].userId : void 0;\n\n        if (userId) {\n          result.user   = () => Meteor.users.findOne(userId);\n          result.userId = userId;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name write\n   * @param {Buffer} buffer - Binary File's Buffer\n   * @param {Object} opts - Object with file-data\n   * @param {String} opts.name - File name, alias: `fileName`\n   * @param {String} opts.type - File mime-type\n   * @param {Object} opts.meta - File additional meta-data\n   * @param {String} opts.userId - UserId, default *null*\n   * @param {String} opts.fileId - _id, default *null*\n   * @param {Function} callback - function(error, fileObj){...}\n   * @param {Boolean} proceedAfterUpload - Proceed onAfterUpload hook\n   * @summary Write buffer to FS and add to FilesCollection Collection\n   * @returns {FilesCollection} Instance\n   */\n  write(buffer, opts = {}, callback, proceedAfterUpload) {\n    this._debug('[FilesCollection] [write()]');\n\n    if (_.isFunction(opts)) {\n      proceedAfterUpload = callback;\n      callback = opts;\n      opts     = {};\n    } else if (_.isBoolean(callback)) {\n      proceedAfterUpload = callback;\n    } else if (_.isBoolean(opts)) {\n      proceedAfterUpload = opts;\n    }\n\n    check(opts, Match.Optional(Object));\n    check(callback, Match.Optional(Function));\n    check(proceedAfterUpload, Match.Optional(Boolean));\n\n    const fileId   = opts.fileId || Random.id();\n    const FSName   = this.namingFunction ? this.namingFunction(opts) : fileId;\n    const fileName = (opts.name || opts.fileName) ? (opts.name || opts.fileName) : FSName;\n\n    const {extension, extensionWithDot} = this._getExt(fileName);\n\n    opts.path = `${this.storagePath(opts)}${nodePath.sep}${FSName}${extensionWithDot}`;\n    opts.type = this._getMimeType(opts);\n    if (!_.isObject(opts.meta)) {\n      opts.meta = {};\n    }\n\n    if (!_.isNumber(opts.size)) {\n      opts.size = buffer.length;\n    }\n\n    const result = this._dataToSchema({\n      name: fileName,\n      path: opts.path,\n      meta: opts.meta,\n      type: opts.type,\n      size: opts.size,\n      userId: opts.userId,\n      extension\n    });\n\n    result._id = fileId;\n\n    const stream = fs.createWriteStream(opts.path, {flags: 'w', mode: this.permissions});\n    stream.end(buffer, (streamErr) => bound(() => {\n      if (streamErr) {\n        callback && callback(streamErr);\n      } else {\n        this.collection.insert(result, (insertErr, _id) => {\n          if (insertErr) {\n            callback && callback(insertErr);\n            this._debug(`[FilesCollection] [write] [insert] Error: ${fileName} -> ${this.collectionName}`, insertErr);\n          } else {\n            const fileRef = this.collection.findOne(_id);\n            callback && callback(null, fileRef);\n            if (proceedAfterUpload === true) {\n              this.onAfterUpload && this.onAfterUpload.call(this, fileRef);\n              this.emit('afterUpload', fileRef);\n            }\n            this._debug(`[FilesCollection] [write]: ${fileName} -> ${this.collectionName}`);\n          }\n        });\n      }\n    }));\n    return this;\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name load\n   * @param {String} url - URL to file\n   * @param {Object} opts - Object with file-data\n   * @param {Object} opts.headers - HTTP headers to use when requesting the file\n   * @param {String} opts.name - File name, alias: `fileName`\n   * @param {String} opts.type - File mime-type\n   * @param {Object} opts.meta - File additional meta-data\n   * @param {String} opts.userId - UserId, default *null*\n   * @param {String} opts.fileId - _id, default *null*\n   * @param {Function} callback - function(error, fileObj){...}\n   * @param {Boolean} proceedAfterUpload - Proceed onAfterUpload hook\n   * @summary Download file, write stream to FS and add to FilesCollection Collection\n   * @returns {FilesCollection} Instance\n   */\n  load(url, opts = {}, callback, proceedAfterUpload) {\n    this._debug(`[FilesCollection] [load(${url}, ${JSON.stringify(opts)}, callback)]`);\n\n    if (_.isFunction(opts)) {\n      proceedAfterUpload = callback;\n      callback = opts;\n      opts     = {};\n    } else if (_.isBoolean(callback)) {\n      proceedAfterUpload = callback;\n    } else if (_.isBoolean(opts)) {\n      proceedAfterUpload = opts;\n    }\n\n    check(url, String);\n    check(opts, Match.Optional(Object));\n    check(callback, Match.Optional(Function));\n    check(proceedAfterUpload, Match.Optional(Boolean));\n\n    if (!_.isObject(opts)) {\n      opts = {};\n    }\n\n    const fileId    = opts.fileId || Random.id();\n    const FSName    = this.namingFunction ? this.namingFunction(opts) : fileId;\n    const pathParts = url.split('/');\n    const fileName  = (opts.name || opts.fileName) ? (opts.name || opts.fileName) : pathParts[pathParts.length - 1] || FSName;\n\n    const {extension, extensionWithDot} = this._getExt(fileName);\n    opts.path  = `${this.storagePath(opts)}${nodePath.sep}${FSName}${extensionWithDot}`;\n\n    const storeResult = (result, cb) => {\n      result._id = fileId;\n\n      this.collection.insert(result, (error, _id) => {\n        if (error) {\n          cb && cb(error);\n          this._debug(`[FilesCollection] [load] [insert] Error: ${fileName} -> ${this.collectionName}`, error);\n        } else {\n          const fileRef = this.collection.findOne(_id);\n          cb && cb(null, fileRef);\n          if (proceedAfterUpload === true) {\n            this.onAfterUpload && this.onAfterUpload.call(this, fileRef);\n            this.emit('afterUpload', fileRef);\n          }\n          this._debug(`[FilesCollection] [load] [insert] ${fileName} -> ${this.collectionName}`);\n        }\n      });\n    };\n\n    request.get({\n      url,\n      headers: opts.headers || {}\n    }).on('error', (error) => bound(() => {\n      callback && callback(error);\n      this._debug(`[FilesCollection] [load] [request.get(${url})] Error:`, error);\n    })).on('response', (response) => bound(() => {\n      response.on('end', () => bound(() => {\n        this._debug(`[FilesCollection] [load] Received: ${url}`);\n        const result = this._dataToSchema({\n          name: fileName,\n          path: opts.path,\n          meta: opts.meta,\n          type: opts.type || response.headers['content-type'] || this._getMimeType({path: opts.path}),\n          size: opts.size || parseInt(response.headers['content-length'] || 0),\n          userId: opts.userId,\n          extension\n        });\n\n        if (!result.size) {\n          fs.stat(opts.path, (error, stats) => bound(() => {\n            if (error) {\n              callback && callback(error);\n            } else {\n              result.versions.original.size = (result.size = stats.size);\n              storeResult(result, callback);\n            }\n          }));\n        } else {\n          storeResult(result, callback);\n        }\n      }));\n    })).pipe(fs.createWriteStream(opts.path, {flags: 'w', mode: this.permissions}));\n\n    return this;\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name addFile\n   * @param {String} path          - Path to file\n   * @param {String} opts          - [Optional] Object with file-data\n   * @param {String} opts.type     - [Optional] File mime-type\n   * @param {Object} opts.meta     - [Optional] File additional meta-data\n   * @param {String} opts.fileId   - _id, default *null*\n   * @param {Object} opts.fileName - [Optional] File name, if not specified file name and extension will be taken from path\n   * @param {String} opts.userId   - [Optional] UserId, default *null*\n   * @param {Function} callback    - [Optional] function(error, fileObj){...}\n   * @param {Boolean} proceedAfterUpload - Proceed onAfterUpload hook\n   * @summary Add file from FS to FilesCollection\n   * @returns {FilesCollection} Instance\n   */\n  addFile(path, opts = {}, callback, proceedAfterUpload) {\n    this._debug(`[FilesCollection] [addFile(${path})]`);\n\n    if (_.isFunction(opts)) {\n      proceedAfterUpload = callback;\n      callback = opts;\n      opts     = {};\n    } else if (_.isBoolean(callback)) {\n      proceedAfterUpload = callback;\n    } else if (_.isBoolean(opts)) {\n      proceedAfterUpload = opts;\n    }\n\n    if (this.public) {\n      throw new Meteor.Error(403, 'Can not run [addFile] on public collection! Just Move file to root of your server, then add record to Collection');\n    }\n\n    check(path, String);\n    check(opts, Match.Optional(Object));\n    check(callback, Match.Optional(Function));\n    check(proceedAfterUpload, Match.Optional(Boolean));\n\n    fs.stat(path, (statErr, stats) => bound(() => {\n      if (statErr) {\n        callback && callback(statErr);\n      } else if (stats.isFile()) {\n        if (!_.isObject(opts)) {\n          opts = {};\n        }\n        opts.path  = path;\n\n        if (!opts.fileName) {\n          const pathParts = path.split(nodePath.sep);\n          opts.fileName   = path.split(nodePath.sep)[pathParts.length - 1];\n        }\n\n        const {extension} = this._getExt(opts.fileName);\n\n        if (!_.isString(opts.type)) {\n          opts.type = this._getMimeType(opts);\n        }\n\n        if (!_.isObject(opts.meta)) {\n          opts.meta = {};\n        }\n\n        if (!_.isNumber(opts.size)) {\n          opts.size = stats.size;\n        }\n\n        const result = this._dataToSchema({\n          name: opts.fileName,\n          path,\n          meta: opts.meta,\n          type: opts.type,\n          size: opts.size,\n          userId: opts.userId,\n          extension,\n          _storagePath: path.replace(`${nodePath.sep}${opts.fileName}`, ''),\n          fileId: opts.fileId || null\n        });\n\n\n        this.collection.insert(result, (insertErr, _id) => {\n          if (insertErr) {\n            callback && callback(insertErr);\n            this._debug(`[FilesCollection] [addFile] [insert] Error: ${result.name} -> ${this.collectionName}`, insertErr);\n          } else {\n            const fileRef = this.collection.findOne(_id);\n            callback && callback(null, fileRef);\n            if (proceedAfterUpload === true) {\n              this.onAfterUpload && this.onAfterUpload.call(this, fileRef);\n              this.emit('afterUpload', fileRef);\n            }\n            this._debug(`[FilesCollection] [addFile]: ${result.name} -> ${this.collectionName}`);\n          }\n        });\n      } else {\n        callback && callback(new Meteor.Error(400, `[FilesCollection] [addFile(${path})]: File does not exist`));\n      }\n    }));\n    return this;\n  }\n\n  /*\n   * @locus Anywhere\n   * @memberOf FilesCollection\n   * @name remove\n   * @param {String|Object} selector - Mongo-Style selector (http://docs.meteor.com/api/collections.html#selectors)\n   * @param {Function} callback - Callback with one `error` argument\n   * @summary Remove documents from the collection\n   * @returns {FilesCollection} Instance\n   */\n  remove(selector, callback) {\n    this._debug(`[FilesCollection] [remove(${JSON.stringify(selector)})]`);\n    if (selector === undefined) {\n      return 0;\n    }\n    check(callback, Match.Optional(Function));\n\n    const files = this.collection.find(selector);\n    if (files.count() > 0) {\n      files.forEach((file) => {\n        this.unlink(file);\n      });\n    } else {\n      callback && callback(new Meteor.Error(404, 'Cursor is empty, no files is removed'));\n      return this;\n    }\n\n    if (this.onAfterRemove) {\n      const docs = files.fetch();\n      const self = this;\n      this.collection.remove(selector, function () {\n        callback && callback.apply(this, arguments);\n        self.onAfterRemove(docs);\n      });\n    } else {\n      this.collection.remove(selector, (callback || NOOP));\n    }\n    return this;\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name deny\n   * @param {Object} rules\n   * @see  https://docs.meteor.com/api/collections.html#Mongo-Collection-deny\n   * @summary link Mongo.Collection deny methods\n   * @returns {Mongo.Collection} Instance\n   */\n  deny(rules) {\n    this.collection.deny(rules);\n    return this.collection;\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name allow\n   * @param {Object} rules\n   * @see https://docs.meteor.com/api/collections.html#Mongo-Collection-allow\n   * @summary link Mongo.Collection allow methods\n   * @returns {Mongo.Collection} Instance\n   */\n  allow(rules) {\n    this.collection.allow(rules);\n    return this.collection;\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name denyClient\n   * @see https://docs.meteor.com/api/collections.html#Mongo-Collection-deny\n   * @summary Shorthands for Mongo.Collection deny method\n   * @returns {Mongo.Collection} Instance\n   */\n  denyClient() {\n    this.collection.deny({\n      insert() { return true; },\n      update() { return true; },\n      remove() { return true; }\n    });\n    return this.collection;\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name allowClient\n   * @see https://docs.meteor.com/api/collections.html#Mongo-Collection-allow\n   * @summary Shorthands for Mongo.Collection allow method\n   * @returns {Mongo.Collection} Instance\n   */\n  allowClient() {\n    this.collection.allow({\n      insert() { return true; },\n      update() { return true; },\n      remove() { return true; }\n    });\n    return this.collection;\n  }\n\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name unlink\n   * @param {Object} fileRef - fileObj\n   * @param {String} version - [Optional] file's version\n   * @param {Function} callback - [Optional] callback function\n   * @summary Unlink files and it's versions from FS\n   * @returns {FilesCollection} Instance\n   */\n  unlink(fileRef, version, callback) {\n    this._debug(`[FilesCollection] [unlink(${fileRef._id}, ${version})]`);\n    if (version) {\n      if (_.isObject(fileRef.versions) && _.isObject(fileRef.versions[version]) && fileRef.versions[version].path) {\n        fs.unlink(fileRef.versions[version].path, (callback || NOOP));\n      }\n    } else {\n      if (_.isObject(fileRef.versions)) {\n        _.each(fileRef.versions, (vRef) => bound(() => {\n          fs.unlink(vRef.path, (callback || NOOP));\n        }));\n      } else {\n        fs.unlink(fileRef.path, (callback || NOOP));\n      }\n    }\n    return this;\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name _404\n   * @summary Internal method, used to return 404 error\n   * @returns {undefined}\n   */\n  _404(http) {\n    this._debug(`[FilesCollection] [download(${http.request.originalUrl})] [_404] File not found`);\n    const text = 'File Not Found :(';\n\n    if (!http.response.headersSent) {\n      http.response.writeHead(404, {\n        'Content-Type': 'text/plain',\n        'Content-Length': text.length\n      }\n      );\n    }\n    if (!http.response.finished) {\n      http.response.end(text);\n    }\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name download\n   * @param {Object} http    - Server HTTP object\n   * @param {String} version - Requested file version\n   * @param {Object} fileRef - Requested file Object\n   * @summary Initiates the HTTP response\n   * @returns {undefined}\n   */\n  download(http, version = 'original', fileRef) {\n    let vRef;\n    this._debug(`[FilesCollection] [download(${http.request.originalUrl}, ${version})]`);\n\n    if (fileRef) {\n      if (_.has(fileRef, 'versions') && _.has(fileRef.versions, version)) {\n        vRef = fileRef.versions[version];\n        vRef._id = fileRef._id;\n      } else {\n        vRef = fileRef;\n      }\n    } else {\n      vRef = false;\n    }\n\n    if (!vRef || !_.isObject(vRef)) {\n      return this._404(http);\n    } else if (fileRef) {\n      if (this.downloadCallback) {\n        if (!this.downloadCallback.call(_.extend(http, this._getUser(http)), fileRef)) {\n          return this._404(http);\n        }\n      }\n\n      if (this.interceptDownload && _.isFunction(this.interceptDownload)) {\n        if (this.interceptDownload(http, fileRef, version) === true) {\n          return void 0;\n        }\n      }\n\n      fs.stat(vRef.path, (statErr, stats) => bound(() => {\n        let responseType;\n        if (statErr || !stats.isFile()) {\n          return this._404(http);\n        }\n\n        if ((stats.size !== vRef.size) && !this.integrityCheck) {\n          vRef.size    = stats.size;\n        }\n\n        if ((stats.size !== vRef.size) && this.integrityCheck) {\n          responseType = '400';\n        }\n\n        return this.serve(http, fileRef, vRef, version, null, (responseType || '200'));\n      }));\n      return void 0;\n    }\n    return this._404(http);\n  }\n\n  /*\n   * @locus Server\n   * @memberOf FilesCollection\n   * @name serve\n   * @param {Object} http    - Server HTTP object\n   * @param {Object} fileRef - Requested file Object\n   * @param {Object} vRef    - Requested file version Object\n   * @param {String} version - Requested file version\n   * @param {stream.Readable|null} readableStream - Readable stream, which serves binary file data\n   * @param {String} responseType - Response code\n   * @param {Boolean} force200 - Force 200 response code over 206\n   * @summary Handle and reply to incoming request\n   * @returns {undefined}\n   */\n  serve(http, fileRef, vRef, version = 'original', readableStream = null, responseType = '200', force200 = false) {\n    let partiral = false;\n    let reqRange = false;\n    let dispositionType = '';\n    let start;\n    let end;\n    let take;\n\n    if (http.params.query.download && (http.params.query.download === 'true')) {\n      dispositionType = 'attachment; ';\n    } else {\n      dispositionType = 'inline; ';\n    }\n\n    const dispositionName     = `filename=\\\"${encodeURI(vRef.name || fileRef.name)}\\\"; filename*=UTF-8''${encodeURI(vRef.name || fileRef.name)}; `;\n    const dispositionEncoding = 'charset=UTF-8';\n\n    if (!http.response.headersSent) {\n      http.response.setHeader('Content-Disposition', dispositionType + dispositionName + dispositionEncoding);\n    }\n\n    if (http.request.headers.range && !force200) {\n      partiral    = true;\n      const array = http.request.headers.range.split(/bytes=([0-9]*)-([0-9]*)/);\n      start       = parseInt(array[1]);\n      end         = parseInt(array[2]);\n      if (isNaN(end)) {\n        end       = vRef.size - 1;\n      }\n      take        = end - start;\n    } else {\n      start = 0;\n      end   = vRef.size - 1;\n      take  = vRef.size;\n    }\n\n    if (partiral || (http.params.query.play && (http.params.query.play === 'true'))) {\n      reqRange = {start, end};\n      if (isNaN(start) && !isNaN(end)) {\n        reqRange.start = end - take;\n        reqRange.end   = end;\n      }\n      if (!isNaN(start) && isNaN(end)) {\n        reqRange.start = start;\n        reqRange.end   = start + take;\n      }\n\n      if ((start + take) >= vRef.size) { reqRange.end = vRef.size - 1; }\n\n      if (this.strict && ((reqRange.start >= (vRef.size - 1)) || (reqRange.end > (vRef.size - 1)))) {\n        responseType = '416';\n      } else {\n        responseType = '206';\n      }\n    } else {\n      responseType = '200';\n    }\n\n    const streamErrorHandler = (error) => {\n      this._debug(`[FilesCollection] [serve(${vRef.path}, ${version})] [500]`, error);\n      if (!http.response.finished) {\n        http.response.end(error.toString());\n      }\n    };\n\n    const headers = _.isFunction(this.responseHeaders) ? this.responseHeaders(responseType, fileRef, vRef, version) : this.responseHeaders;\n\n    if (!headers['Cache-Control']) {\n      if (!http.response.headersSent) {\n        http.response.setHeader('Cache-Control', this.cacheControl);\n      }\n    }\n\n    for (let key in headers) {\n      if (!http.response.headersSent) {\n        http.response.setHeader(key, headers[key]);\n      }\n    }\n\n    const respond = (stream, code) => {\n      if (!http.response.headersSent && readableStream) {\n        http.response.writeHead(code);\n      }\n\n      http.response.on('close', () => {\n        if (typeof stream.abort === 'function') {\n          stream.abort();\n        }\n        if (typeof stream.end === 'function') {\n          stream.end();\n        }\n      });\n\n      http.request.on('aborted', () => {\n        http.request.aborted = true;\n        if (typeof stream.abort === 'function') {\n          stream.abort();\n        }\n        if (typeof stream.end === 'function') {\n          stream.end();\n        }\n      });\n\n      stream.on('open', () => {\n        if (!http.response.headersSent) {\n          http.response.writeHead(code);\n        }\n      }).on('abort', () => {\n        if (!http.response.finished) {\n          http.response.end();\n        }\n        if (!http.request.aborted) {\n          http.request.destroy();\n        }\n      }).on('error', streamErrorHandler\n      ).on('end', () => {\n        if (!http.response.finished) {\n          http.response.end();\n        }\n      }).pipe(http.response);\n    };\n\n    switch (responseType) {\n    case '400':\n      this._debug(`[FilesCollection] [serve(${vRef.path}, ${version})] [400] Content-Length mismatch!`);\n      var text = 'Content-Length mismatch!';\n\n      if (!http.response.headersSent) {\n        http.response.writeHead(400, {\n          'Content-Type': 'text/plain',\n          'Content-Length': text.length\n        });\n      }\n\n      if (!http.response.finished) {\n        http.response.end(text);\n      }\n      break;\n    case '404':\n      this._404(http);\n      break;\n    case '416':\n      this._debug(`[FilesCollection] [serve(${vRef.path}, ${version})] [416] Content-Range is not specified!`);\n      if (!http.response.headersSent) {\n        http.response.writeHead(416);\n      }\n      if (!http.response.finished) {\n        http.response.end();\n      }\n      break;\n    case '206':\n      this._debug(`[FilesCollection] [serve(${vRef.path}, ${version})] [206]`);\n      if (!http.response.headersSent) {\n        http.response.setHeader('Content-Range', `bytes ${reqRange.start}-${reqRange.end}/${vRef.size}`);\n      }\n      respond(readableStream || fs.createReadStream(vRef.path, {start: reqRange.start, end: reqRange.end}), 206);\n      break;\n    default:\n      this._debug(`[FilesCollection] [serve(${vRef.path}, ${version})] [200]`);\n      respond(readableStream || fs.createReadStream(vRef.path), 200);\n      break;\n    }\n  }\n}\n"]},"hash":"53adf30307c6980eb5e028a24fb2c0e7d5771883"}
