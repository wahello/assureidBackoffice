{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/tracker","imported":["Tracker"],"specifiers":[{"kind":"named","imported":"Tracker","local":"Tracker"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/ultimatejs:tracker-react/Tracker.js","filenameRelative":"packages/ultimatejs:tracker-react/Tracker.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/ultimatejs:tracker-react/Tracker.js.map","sourceFileName":"packages/ultimatejs:tracker-react/Tracker.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"Tracker"},"ignored":false,"code":"var Tracker = void 0;\nmodule.watch(require(\"meteor/tracker\"), {\n  Tracker: function (v) {\n    Tracker = v;\n  }\n}, 0);\n\n/**\n * Create \"one-time\" reactive computations with Tracker\n * @param name {string} Component Reactive Data Property for Computation\n * @param context {*} Target Component Instance\n * @param dataFunc {*} Data Context\n * @param updateFunc {*} Component ForceUpdate Method - To re-trigger render function\n * @returns {*} Symbol(react.element) - Result data-element composition\n */Tracker.once = function (name, context, dataFunc, updateFunc) {\n  var data = void 0; // Stop it just in case the autorun never re-ran\n\n  if (context[name] && !context[name].stopped) context[name].stop(); // NOTE: we may want to run this code in `setTimeout(func, 0)` so it doesn't impact the rendering phase at all\n\n  context[name] = Tracker.nonreactive(function () {\n    return Tracker.autorun(function (c) {\n      if (c.firstRun) {\n        data = dataFunc.call(context);\n      } else {\n        // Stop autorun here so rendering \"phase\" doesn't have extra work of also stopping autoruns; likely not too\n        // important though.\n        if (context[name]) context[name].stop(); // where `forceUpdate` will be called in above implementation\n\n        updateFunc.call(context);\n      }\n    });\n  });\n  return data;\n};\n\nmodule.exportDefault(Tracker);","map":{"version":3,"sources":["packages/ultimatejs:tracker-react/Tracker.js"],"names":["Tracker","module","watch","require","v","once","name","context","dataFunc","updateFunc","data","stopped","stop","nonreactive","autorun","c","firstRun","call","exportDefault"],"mappings":"AAAA,IAAIA,gBAAJ;AAAYC,OAAOC,KAAP,CAAaC,QAAQ,gBAAR,CAAb,EAAuC;AAACH,SAAD,YAASI,CAAT,EAAW;AAACJ,cAAQI,CAAR;AAAU;AAAtB,CAAvC,EAA+D,CAA/D;;AAGZ;;;;;;;GAQAJ,QAAQK,IAAR,GAAe,UAAUC,IAAV,EAAgBC,OAAhB,EAAyBC,QAAzB,EAAmCC,UAAnC,EAA+C;AAC5D,MAAIC,aAAJ,CAD4D,CAG5D;;AACA,MAAIH,QAAQD,IAAR,KAAiB,CAACC,QAAQD,IAAR,EAAcK,OAApC,EAA6CJ,QAAQD,IAAR,EAAcM,IAAd,GAJe,CAM5D;;AACAL,UAAQD,IAAR,IAAgBN,QAAQa,WAAR,CAAoB,YAAM;AACxC,WAAOb,QAAQc,OAAR,CAAgB,aAAK;AAC1B,UAAIC,EAAEC,QAAN,EAAgB;AAEdN,eAAOF,SAASS,IAAT,CAAcV,OAAd,CAAP;AAED,OAJD,MAIO;AAEL;AACA;AACA,YAAIA,QAAQD,IAAR,CAAJ,EAAmBC,QAAQD,IAAR,EAAcM,IAAd,GAJd,CAML;;AACAH,mBAAWQ,IAAX,CAAgBV,OAAhB;AACD;AACF,KAdM,CAAP;AAeD,GAhBe,CAAhB;AAkBA,SAAOG,IAAP;AACD,CA1BD;;AAXAT,OAAOiB,aAAP,CAuCelB,OAvCf","file":"packages/ultimatejs:tracker-react/Tracker.js.map","sourcesContent":["// Also available as a global\nimport {Tracker} from 'meteor/tracker';\n\n/**\n * Create \"one-time\" reactive computations with Tracker\n * @param name {string} Component Reactive Data Property for Computation\n * @param context {*} Target Component Instance\n * @param dataFunc {*} Data Context\n * @param updateFunc {*} Component ForceUpdate Method - To re-trigger render function\n * @returns {*} Symbol(react.element) - Result data-element composition\n */\nTracker.once = function (name, context, dataFunc, updateFunc) {\n  let data;\n\n  // Stop it just in case the autorun never re-ran\n  if (context[name] && !context[name].stopped) context[name].stop();\n\n  // NOTE: we may want to run this code in `setTimeout(func, 0)` so it doesn't impact the rendering phase at all\n  context[name] = Tracker.nonreactive(() => {\n    return Tracker.autorun(c => {\n      if (c.firstRun) {\n\n        data = dataFunc.call(context);\n\n      } else {\n\n        // Stop autorun here so rendering \"phase\" doesn't have extra work of also stopping autoruns; likely not too\n        // important though.\n        if (context[name]) context[name].stop();\n\n        // where `forceUpdate` will be called in above implementation\n        updateFunc.call(context);\n      }\n    });\n  });\n\n  return data;\n};\n\nexport default Tracker"]},"hash":"fb024a322ec9b10cc5c80980719474f92b63bfd8"}
