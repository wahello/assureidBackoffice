{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"fs-extra","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"fs"}]},{"source":"meteor/underscore","imported":["_"],"specifiers":[{"kind":"named","imported":"_","local":"_"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]}],"exports":{"exported":["WriteStream"],"specifiers":[{"kind":"local","local":"WriteStream","exported":"default"}]}}},"options":{"filename":"packages/ostrio:files/write-stream.js","filenameRelative":"packages/ostrio:files/write-stream.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/ostrio:files/write-stream.js.map","sourceFileName":"packages/ostrio:files/write-stream.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"write-stream"},"ignored":false,"code":"module.export({\n  default: () => WriteStream\n});\nlet fs;\nmodule.watch(require(\"fs-extra\"), {\n  default(v) {\n    fs = v;\n  }\n\n}, 0);\n\nlet _;\n\nmodule.watch(require(\"meteor/underscore\"), {\n  _(v) {\n    _ = v;\n  }\n\n}, 1);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 2);\n\nconst NOOP = () => {}; /*\n                        * @const {Object} bound   - Meteor.bindEnvironment (Fiber wrapper)\n                        * @const {Object} fdCache - File Descriptors Cache\n                        */\n\nconst bound = Meteor.bindEnvironment(callback => callback());\nconst fdCache = {}; /*\n                     * @private\n                     * @locus Server\n                     * @class WriteStream\n                     * @param path      {String} - Path to file on FS\n                     * @param maxLength {Number} - Max amount of chunks in stream\n                     * @param file      {Object} - fileRef Object\n                     * @summary writableStream wrapper class, makes sure chunks is written in given order. Implementation of queue stream.\n                     */\n\nclass WriteStream {\n  constructor(path, maxLength, file, permissions) {\n    this.path = path;\n    this.maxLength = maxLength;\n    this.file = file;\n    this.permissions = permissions;\n\n    if (!this.path || !_.isString(this.path)) {\n      return;\n    }\n\n    this.fd = null;\n    this.writtenChunks = 0;\n    this.ended = false;\n    this.aborted = false;\n\n    if (fdCache[this.path] && !fdCache[this.path].ended && !fdCache[this.path].aborted) {\n      this.fd = fdCache[this.path].fd;\n      this.writtenChunks = fdCache[this.path].writtenChunks;\n    } else {\n      fs.ensureFile(this.path, efError => {\n        bound(() => {\n          if (efError) {\n            throw new Meteor.Error(500, '[FilesCollection] [writeStream] [ensureFile] [Error:]', efError);\n          } else {\n            fs.open(this.path, 'r+', this.permissions, (oError, fd) => {\n              bound(() => {\n                if (oError) {\n                  throw new Meteor.Error(500, '[FilesCollection] [writeStream] [ensureFile] [open] [Error:]', oError);\n                } else {\n                  this.fd = fd;\n                  fdCache[this.path] = this;\n                }\n              });\n            });\n          }\n        });\n      });\n    }\n  } /*\n     * @memberOf writeStream\n     * @name write\n     * @param {Number} num - Chunk position in a stream\n     * @param {Buffer} chunk - Buffer (chunk binary data)\n     * @param {Function} callback - Callback\n     * @summary Write chunk in given order\n     * @returns {Boolean} - True if chunk is sent to stream, false if chunk is set into queue\n     */\n\n  write(num, chunk, callback) {\n    if (!this.aborted && !this.ended) {\n      if (this.fd) {\n        fs.write(this.fd, chunk, 0, chunk.length, (num - 1) * this.file.chunkSize, (error, written, buffer) => {\n          bound(() => {\n            callback && callback(error, written, buffer);\n\n            if (error) {\n              console.warn('[FilesCollection] [writeStream] [write] [Error:]', error);\n              this.abort();\n            } else {\n              ++this.writtenChunks;\n            }\n          });\n        });\n      } else {\n        Meteor.setTimeout(() => {\n          this.write(num, chunk, callback);\n        }, 25);\n      }\n    }\n\n    return false;\n  } /*\n     * @memberOf writeStream\n     * @name end\n     * @param {Function} callback - Callback\n     * @summary Finishes writing to writableStream, only after all chunks in queue is written\n     * @returns {Boolean} - True if stream is fulfilled, false if queue is in progress\n     */\n\n  end(callback) {\n    if (!this.aborted && !this.ended) {\n      if (this.writtenChunks === this.maxLength) {\n        fs.close(this.fd, () => {\n          bound(() => {\n            delete fdCache[this.path];\n            this.ended = true;\n            callback && callback(void 0, true);\n          });\n        });\n        return true;\n      }\n\n      fs.stat(this.path, (error, stat) => {\n        bound(() => {\n          if (!error && stat) {\n            this.writtenChunks = Math.ceil(stat.size / this.file.chunkSize);\n          }\n\n          return Meteor.setTimeout(() => {\n            this.end(callback);\n          }, 25);\n        });\n      });\n    } else {\n      callback && callback(void 0, this.ended);\n    }\n\n    return false;\n  } /*\n     * @memberOf writeStream\n     * @name abort\n     * @param {Function} callback - Callback\n     * @summary Aborts writing to writableStream, removes created file\n     * @returns {Boolean} - True\n     */\n\n  abort(callback) {\n    this.aborted = true;\n    delete fdCache[this.path];\n    fs.unlink(this.path, callback || NOOP);\n    return true;\n  } /*\n     * @memberOf writeStream\n     * @name stop\n     * @summary Stop writing to writableStream\n     * @returns {Boolean} - True\n     */\n\n  stop() {\n    this.aborted = true;\n    delete fdCache[this.path];\n    return true;\n  }\n\n}","map":{"version":3,"sources":["packages/ostrio:files/write-stream.js"],"names":["module","export","default","WriteStream","fs","watch","require","v","_","Meteor","NOOP","bound","bindEnvironment","callback","fdCache","constructor","path","maxLength","file","permissions","isString","fd","writtenChunks","ended","aborted","ensureFile","efError","Error","open","oError","write","num","chunk","length","chunkSize","error","written","buffer","console","warn","abort","setTimeout","end","close","stat","Math","ceil","size","unlink","stop"],"mappings":"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","file":"packages/ostrio:files/write-stream.js.map","sourcesContent":["import fs         from 'fs-extra';\nimport { _ }      from 'meteor/underscore';\nimport { Meteor } from 'meteor/meteor';\nconst NOOP = () => {};\n\n/*\n * @const {Object} bound   - Meteor.bindEnvironment (Fiber wrapper)\n * @const {Object} fdCache - File Descriptors Cache\n */\nconst bound   = Meteor.bindEnvironment(callback => callback());\nconst fdCache = {};\n\n/*\n * @private\n * @locus Server\n * @class WriteStream\n * @param path      {String} - Path to file on FS\n * @param maxLength {Number} - Max amount of chunks in stream\n * @param file      {Object} - fileRef Object\n * @summary writableStream wrapper class, makes sure chunks is written in given order. Implementation of queue stream.\n */\nexport default class WriteStream {\n  constructor(path, maxLength, file, permissions) {\n    this.path = path;\n    this.maxLength = maxLength;\n    this.file = file;\n    this.permissions = permissions;\n    if (!this.path || !_.isString(this.path)) {\n      return;\n    }\n\n    this.fd            = null;\n    this.writtenChunks = 0;\n    this.ended         = false;\n    this.aborted       = false;\n\n    if (fdCache[this.path] && !fdCache[this.path].ended && !fdCache[this.path].aborted) {\n      this.fd = fdCache[this.path].fd;\n      this.writtenChunks = fdCache[this.path].writtenChunks;\n    } else {\n      fs.ensureFile(this.path, (efError) => {\n        bound(() => {\n          if (efError) {\n            throw new Meteor.Error(500, '[FilesCollection] [writeStream] [ensureFile] [Error:]', efError);\n          } else {\n            fs.open(this.path, 'r+', this.permissions, (oError, fd) => {\n              bound(() => {\n                if (oError) {\n                  throw new Meteor.Error(500, '[FilesCollection] [writeStream] [ensureFile] [open] [Error:]', oError);\n                } else {\n                  this.fd = fd;\n                  fdCache[this.path] = this;\n                }\n              });\n            });\n          }\n        });\n      });\n    }\n  }\n\n  /*\n   * @memberOf writeStream\n   * @name write\n   * @param {Number} num - Chunk position in a stream\n   * @param {Buffer} chunk - Buffer (chunk binary data)\n   * @param {Function} callback - Callback\n   * @summary Write chunk in given order\n   * @returns {Boolean} - True if chunk is sent to stream, false if chunk is set into queue\n   */\n  write(num, chunk, callback) {\n    if (!this.aborted && !this.ended) {\n      if (this.fd) {\n        fs.write(this.fd, chunk, 0, chunk.length, (num - 1) * this.file.chunkSize, (error, written, buffer) => {\n          bound(() => {\n            callback && callback(error, written, buffer);\n            if (error) {\n              console.warn('[FilesCollection] [writeStream] [write] [Error:]', error);\n              this.abort();\n            } else {\n              ++this.writtenChunks;\n            }\n          });\n        });\n      } else {\n        Meteor.setTimeout(() => {\n          this.write(num, chunk, callback);\n        }, 25);\n      }\n    }\n    return false;\n  }\n\n  /*\n   * @memberOf writeStream\n   * @name end\n   * @param {Function} callback - Callback\n   * @summary Finishes writing to writableStream, only after all chunks in queue is written\n   * @returns {Boolean} - True if stream is fulfilled, false if queue is in progress\n   */\n  end(callback) {\n    if (!this.aborted && !this.ended) {\n      if (this.writtenChunks === this.maxLength) {\n        fs.close(this.fd, () => {\n          bound(() => {\n            delete fdCache[this.path];\n            this.ended = true;\n            callback && callback(void 0, true);\n          });\n        });\n        return true;\n      }\n\n      fs.stat(this.path, (error, stat) => {\n        bound(() => {\n          if (!error && stat) {\n            this.writtenChunks = Math.ceil(stat.size / this.file.chunkSize);\n          }\n\n          return Meteor.setTimeout(() => {\n            this.end(callback);\n          }, 25);\n        });\n      });\n    } else {\n      callback && callback(void 0, this.ended);\n    }\n    return false;\n  }\n\n  /*\n   * @memberOf writeStream\n   * @name abort\n   * @param {Function} callback - Callback\n   * @summary Aborts writing to writableStream, removes created file\n   * @returns {Boolean} - True\n   */\n  abort(callback) {\n    this.aborted = true;\n    delete fdCache[this.path];\n    fs.unlink(this.path, (callback || NOOP));\n    return true;\n  }\n\n  /*\n   * @memberOf writeStream\n   * @name stop\n   * @summary Stop writing to writableStream\n   * @returns {Boolean} - True\n   */\n  stop() {\n    this.aborted = true;\n    delete fdCache[this.path];\n    return true;\n  }\n}\n"]},"hash":"8c44c950b13228eb27c98501b772f60f60d62527"}
